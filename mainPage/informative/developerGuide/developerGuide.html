<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS V4 Developer's Guide</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>EPICS V4 Developer's Guide</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 01-September-2016</h2>
<p>
<b>NOTE: If you are using EPICS V4 Release 4.5 then look at the previous version.</b>
</p>
<p>
This version is for EPICS V4 Release 4.6.
</p>

  <dl>
    <dt>Latest version:</dt>
    <dd>
      <a href="developerGuide.html">developerGuide.html</a>
    </dd>
    <dt>This version:</dt>
    <dd>
       <a href="developerGuide_20160901.html">developerGuide_V4Release4_6.html</a>
    </dd>
    <dt>Previous version:</dt>
    <dd>
       <a href="developerGuide_20150825.html">developerGuide_V4Release4_5.html</a>
    </dd>

    <dt>Editors:</dt>
   <dd> Marty Kraimer, BNL<br />
      David Hickin, Diamond Light Source<br />
      Matej Sekoranja, CosyLab
      </dd>
  </dl>

<h2 class="nocount">Abstract</h2>

<p>This is Developer's Guide for EPICS V4,
which is one of a
related set of products:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>

</div>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Overview of V4</h2>
<p>
This document briefly describes a set of application programming interfaces (APIs)
for EPICS V4.</p>
<p>
These core APIs provide a toolkit for creating applications that access and/or provide sources of structured data. This document is intended for EPICS V4 software developers who want to implement applications via the core APIs.
</p>
<h3>V4 Modules</h3>
V4 includes the following core components:
<dl>
   <dt>pvData</dt>
      <dd>
       The EPICS V4 type system, which describes and implements structured data.
      </dd>
   <dt>normativeTypes</dt>
      <dd>
        A set of standard pvData structures.
      </dd>
   <dt>pvAccess</dt>
      <dd>
       Support for connecting a client and server and for transporting pvData between client and server.
      </dd>
   <dt>pvaClient</dt>
      <dd>
       pvAccess is a callback based API. pvaClient is a synchronous interface for pvAccess and also provides a number of convenience methods.
      </dd>
   <dt>pvDatabase</dt>
      <dd>
       A memory resident database of PVRecords and a pvAccess channel provider for accessing the PVRecords.
      </dd>
   <dt>pvaSrv</dt>
      <dd>
       A pvAccess channel provider for EPICS V3 DBRecords.
      </dd>
   <dt>example</dt>
       <dd>
       A set of examples that use all of the above components.
       </dd>
    <dt>pvaPy</dt>
       <dd>
       Python wrapper for pvData and pvAccess.
       </dd>
</dl>


<p><b>pvaSrv</b> and <b>pvaPy</b> are implemented only in C++.
Each has a single github repository.
</p>
<p>
The other components are implemented in both C++ and Java,
with each language having it's own github repository.
For example pvData has the repositories
<a href="https://github.com/epics-base/pvDataJava">pvDataJava</a>
and
<a href="https://github.com/epics-base/pvDataCPP">pvDataCPP</a>
</p>
<h3>Terminology</h3>
<dl>
   <dt>API - Application Programming Interface </dt>
     <dd>
      The pvData API is how a client accesses the type system
      and data objects for each type.
      In Java this consists mainly of Java interfaces.
      In C++ this is via C++ classes.
       This document uses a combination of <b>psuedo</b> code, Java code, and C++ code for describing
       APIs. It uses <b>psuedo</b> code when there is equivalent code in Java and in C++.
      The <b>psuedo</b> code is similar to Java interface definitions.
       The language specific APIs are provided in separate projects
       e. g. pvDataJava, and pvDataCPP.
       This document also describes the APIs for the other V4 core modules.
      </dd>
   <dt>Introspection API</dt>
      <dd>The type system supports both introspection and data interfaces.
       The introspection interfaces allow a client to determine the data types for objects
       without requiring a data instance.
      </dd>
   <dt>Data API</dt>
     <dd>These provide access to data instances.
     </dd>
     <dt>type</dt>
        <dd>Often used when talking about a field.
          In this case it means the intospection interface for the field.
        </dd>
     <dt>PVScalarType</dt>
       <dd>Generic name for the data type for a scalar.
        Thus a generic name for one of PVBoolean, PVByte, ..., PVString.
        </dd>
     <dt>PVScalarArrayType</dt>
       <dd>Generic name for the data type for a scalarArray.
        This a generic name for one of PVBooleanArray,
         PVByteArray, ..., PVStringArray.
        </dd>
     <dt>PVType</dt>
       <dd>Generic name for any valid Data API type.
        </dd>
     <dt>Special Field</dt>
        <dd>These are a set standard structure definitions:
        <b>enum</b>, <b>alarm</b>, <b>timeStamp</b>, <b>control</b>, <b>display</b>, and <b>alarmLimit</b>.
        </dd>
</dl>
<h3>Overview: pvData</h3>
pvData supports structured data where a structure is a set of fields.
Each field is composed of one of the following types:
<dl>
   <dt>scalar</dt>
      <dd>
        The field holds data that has a single scalarType:
        <dl>
            <dt>boolean</dt>
               <dd>Can be <b>true</b> or <b>false</b>.
               </dd>
            <dt>signed Integer</dt>
               <dd>Integers of 8, 16, 32, and 64 bits are supported.</dd>
            <dt>unsigned Integer</dt>
                <dd>Unsigned integers of 8, 16, 32, and 64 bits are supported.</dd>
            <dt>float</dt>
                <dd>IEEE 32 bit floating point.</dd>
            <dt>double</dt>
                <dd>IEEE 64 bit floating point.</dd>
            <dt>string</dt>
                <dd>In C++ std::string and in Java String. On network UTF8.</dd>
        </dl>
      </dd>
   <dt>scalarArray</dt>
      <dd>An array of one of the scalar types.</dd>
   <dt>structure</dt>
      <dd>A set of fields and a name for each field.
       Each field can have any valid type but the type can not change.
      </dd>
   <dt>structureArray</dt>
      <dd>
       An array of structures. Each element must have the same introspection interface.
      </dd>
   <dt>union</dt>
      <dd>
        A field that has a single sub field which can dynamically change type.
      A variant union allows any valid type. A restricted union allows for a set of valid types.
      </dd>
   <dt>unionArray</dt>
      <dd>
       A array of unions. Each element must have the same introspection interface.
      </dd>
</dl>
<h3>Overview: normativeTypes</h3>
<p>Each normative type defines a structure that has a set of standard fields.
For example NTScalar defines:</p>
<pre>
epics:nt/NTScalar:1.0
    double value                        // mandatory and can be any numeric type
    string descriptor                   // optional
    alarm_t alarm                       // optional
        int severity
        int status
        string message
    time_t timeStamp                    // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    display_t display                   // optional
        double limitLow
        double limitHigh
        string description
        string format
        string units
    control_t control                   // optional
        double limitLow
        double limitHigh
        double minStep
    string extra1                       // extra
    string[] extra2                     //
</pre>
<h3>Overview: pvAccess</h3>
<p>
A client written in either Java or C++ can communicate with a server written in either Java or C++.
All communication between client and server is done via the methods provided by pvAccess and by pvData objects.
</p>
<p>
pvAccess provides:</p>
<dl>
   <dt>channelProviderRegistry</dt>
     <dd>An arbitrary number of channelProviders can be created</dd>
   <dt>channelProvider</dt>
     <dd>Code that provides access to a pvData data source.
      It creates channels.<br />
       A channel:
       <ul>
          <li>Provides access to a pvData structure.</li>
          <li>Has an associated channelName.</li>
       </ul>
     </dd>
   <dt>channel</dt>
      <dd>Methods for each of the following:
        <dl>
           <dt>getField</dt>
              <dd>Get the pvData introspection information.</dd>
           <dt>channelGet</dt>
              <dd>Get data.</dd>
           <dt>channelPut</dt>
               <dd>Put data.</dd>
           <dt>channelPutGet</dt>
               <dd>Put data, let server process it, and then get result.</dd>
           <dt>monitor</dt>
               <dd>Monitor pvData changes.</dd>
           <dt>channelArray</dt>
               <dd>get/put subArray data.</dd>
           <dt>channelRPC</dt>
               <dd>Like channelPutGet but on each request pvData
                 interfaces for put and get can change.</dd>
        </dl>
       </dd>
</dl>
<p>
channelPutGet and channelRPC provide the equivalent of a Remote Procedure Call.
The client passes a pvData object to the server.
This pvData object is the argument for the RPC.
The server uses this to decide what to do
and sends a pvData object back to the client, which is the RPC result.
</p>
<h3>Overview: pvaClient</h3>
<p>pvaClient is a synchronous wrapper for the pvAccess API, which is a callback based API.
In addition pvaClient provides many convenience methods.
Thus it is easier to use than pvAccess itself.
</p>
<h3>Overview: pvDatabase</h3>
<p>A framework for implementing a network accessible database of smart memory resident
records. Network access is via pvAccess. The data in each record is a top level PVStructure as defined by
pvData. The framework includes a complete implementation of ChannelProvider as defined by pvAccess.
The framework can be extended in order to create record instances that implement services.
The minimum that an extension must provide is a top level PVStructure and a process method.
</p>

<h3>Overview: pvaSrv</h3>
<p><b>pvaSrv</b> is a channel provider for DBRecords in an EPICS V3 IOC.
pvaSrv allows clients to get, put and monitor V3 PVs (fields of EPICS DB records) via pvAccess, translating
the value and its meta data (graphics limits, alarm status, timestamp) to or from V4 Normative Type (NT)
pvData structures (NTScalar, NTScalarArray).</p>
<h3>Overview: pvaPy</h3>
<p>A Python wrapper for pvData and pvAccess.</p>
<h3>Overview: channelProvider</h3>
<p>The basic requirements for a channel provider are:</p>
<ol>
   <li>Given a channel name, find and connect to the data source</li>
   <li>Implement one or more of the channel methods: getField, createChannelGet, etc.</li>
   <li>get/put all data as pvData.</li>
   <li>Prefer normative types instead of raw pvData</li>
</ol>
<p><b>pvAccess</b> implements <b>channelProviderRegistry</b>, which
allows an arbitrary number of providers.
</p>
<p>
A provider is one of the following:</p>
<dl>
   <dt>Client Provider</dt>
     <dd>Called by code that wants to access a <b>channel</b>, where
       each channel has a unique channel name</dd>
   <dt>Server Provider</dt>
     <dd>A provider for the remote side of the <b>pva</b> provider, which is
       described next.</dd>
</dl>
<p>
Before either kind of provider can be used it must first register itself with the 
<b>channelProviderRegistry</b>
</p>
<h4>Provider pva</h4>
<p>An important component of EPICS V4 is provider <b>pva</b>, which is a provider
that implements a connection between a client and a server that uses the pva network
      protocal as defined in:
         <a
          href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html">
          pvAccess_Protocol_Specification.html</a>
</p>
<p>Provider <b>pva</b> has two components:</p>
<dl>
  <dt>client</dt>
     <dd>This is what a pvAccess client uses.</dd>
  <dt>remote</dt>
     <dd>This connects to server providers</dd>
</dl>
<p>Network communcation is used between client and server.
Remote <b>pva</b> transfers data between the network and channel providers that
have registered at the remote node.</p>
<h4>Client Providers</h4>
<p>An arbitrary number of client providers can be implemented.
Each provider must implement the <b>channel</b> interface
mentioned above and must register with the <b>channelProviderRegistry</b>
before it can be used by a client.
</p>
<p>pvAccess itself provides the following client providers:</p>
<dl>
   <dt>pva</dt>
      <dd>The client side of provider <b>pva</b>.
       </dd>
   <dt>ca</dt>
     <dd>This is a connection that uses channel access to access an epics V3 channel.</dd>
   <dt>pipelineService</dt>
      <dd>
       A pipelineService is a service that provides a lossless channel monitor.
       A client requests access to a pipelineService via a pvRequest argument.<br />
      pvGet and eget provide support.<br />
      Other clients could also access a server that implements a pipelineService.
       </dd>
</dl>
<h4>Server Providers</h4>
<p>At present the following providers are available for the remote side of <b>pva</b></p>
<dl>
   <dt>local</dt>
      <dd>This is implemented by pvDatabase</dd>
   <dt>pvaSrv</dt>
      <dd>This is a provider that directly accesses V3 DBRecord.</dd>
   <dt>pipelineService</dt>
      <dd>
        
         pvAccess provides a helper class for a service that wants to implement a  pipelineService.
      </dd>
</dl>
<h4>Client Provider Choices</h4>
<p>At present a client that is not running as part of a V3 IOC or a pvDatabase
has two choices for channelProvider: <b>pva</b> and <b>ca</b>.
A client running as part of a V3 IOC that is also
using pvDatabase has all of the following choices:
<b>pva</b>, <b>ca</b>, <b>local</b>, and <b>pvSrv</b>.
Note that if a client directly connects to either <b>local</b> or <b>pvSrv</b>
no network communication is involved.
</p>
<p>
And since <b>channelProviderRegistry</b> allows any arbitrary number of providers
additional providers can be developed for either the client or remote side of <b>pva</b>.
</p>


<h3>EPICS V4 resources and website</h3>
<p>This document is a tutorial rather then a detailed reference manual.
The following should be consulted for detailed documentation:</p>
<ul>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/tip/documentation/pvDataJava.html">
    pvDataJava</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvDataCPP/tip/documentation/pvDataCPP.html">
    pvDataCPP</a>
    </li>
    <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/normativeTypesJava/tip/documentation/ntJava.html">
    normativeTypesJava</a>
    </li>
    <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/normativeTypesCPP/tip/documentation/ntCPP.html">
    normativeTypesCPP</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvAccessJava/tip/documentation/pvAccessJava.html">
    pvAccessJava</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvAccessCPP/tip/documentation/pvAccessCPP.html">
    pvAccessCPP</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvaClientJava/tip/documentation/pvaClientJava.html">
    pvaClientJava</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvaClientCPP/tip/documentation/pvaClientCPP.html">
    pvaClientCPP</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvDatabaseJava/tip/documentation/pvDatabaseJava.html">
    pvDatabaseJava</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvDatabaseCPP/tip/documentation/pvDatabaseCPP.html">
    pvDatabaseCPP</a>
    </li>
    <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/exampleJava/tip/documentation/exampleJava.html">
    exampleJava</a>
    </li>
   <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/exampleCPP/tip/documentation/exampleCPP.html">
    exampleCPP</a>
    </li>
    <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvaSrv/tip/documentation/pvaSrv.html">
    pvaSrv</a>
    </li>
    <li>
    <a target="_top"
    href="http://epics-pvdata.sourceforge.net/docbuild/pvaPy/tip/documentation/pvaPy.html">
    pvaPy</a>
    </li>
  
</ul>
<p>In addition the following are standards:</p>
<ul>
    <li><a href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html">
  Network protocol for <b>pva</b> provider</a>
   </li>
    <li><a href="http://epics-pvdata.sourceforge.net/alpha/normativeTypes/normativeTypes.html">
  Normative Types Specification</a>
   </li>
</ul>
<h3>Current Status</h3>
<dl>
   <dt>pvData</dt>
      <dd>
       EPICS V4 Release 4.6 has a complete implementation for both Java and C++.
      </dd>
   <dt>normativeTypes</dt>
      <dd>
       EPICS V4 Release 4.6 has C++ and Java helper classes for many, but not all, of the normative types.
      </dd>
   <dt>pvAccess</dt>
      <dd>
       EPICS V4 Release 4.6 has a complete implementation for both C++ and Java.
      </dd>
   <dt>pvaClient</dt>
      <dd>
       EPICS V4 Release 4.6 has an implementation for both Java and CPP<br />
       However getField and channelArray are not implemented.
      </dd>
   <dt>pvDatabase</dt>
      <dd>
       EPICS V4 Release 4.6  has an implementation for both C++ and Java.
       For C++ the pvDatabase can run as part of a V3 IOC.
      </dd>
   <dt>example</dt>
      <dd>
      EPICS V4 Release 4.6 has an implementation for both C++ and Java.
      </dd>
   <dt>pvaSrv</dt>
      <dd>
       EPICS V4 Release 4.6  has an implementation for C++.
       Since this is for iocCore a Java implementation is not necessary.
      </dd>
    <dt>pvaPy</dt>
       <dd>
       EPICS V4 Release 4.6  has an implementation for C++.
       Since this is for Python a Java implementation is not necessary.
       </dd>
</dl>
<h2>pvlist, pvget, pvput, and eget</h2>
<p>pvAccessCPP provides command line tools. Each provides help. For example:</p>
<pre>
pvlist -help
</pre>
<p>
The examples shown in this section assume that the example database described in the next secton is running.
Also your <b>PATH</b> environment variable must include the appropriate bin directory from pvAccessCPP.
For example:</p>
<pre>
export PATH=$PATH:${EPICSV4}/pvAccessCPP/bin/${EPICS_HOST_ARCH}
</pre>
<h3>pvlist</h3>
<p>The options are:</p>
<pre>
mrk> pvlist -help

Usage: pvlist [options] [server address or GUID starting with '0x']...

  -h: Help: Print this message
options:
  -i                 Print server info (when server address list/GUID is given)
  -w sec:            Wait time, specifies timeout, default is 3.000000 second(s)
  -q:                Quiet mode, print only error messages
  -d:                Enable debug output

examples:
	pvlist
	pvlist ioc0001
	pvlist 10.5.1.205:10000
	pvlist 0x83DE3C540000000000BF351F
</pre>
<p>Without any arguments this shows the location of all V4 servers it can locate.
For example:</p>
<pre>
pvlist
GUID 0x7F06B2560000000047B97D25, version 1: tcp@[192.168.124.1:45345, 10.0.0.37:45345]
</pre>
<p>This only shows one line because only the exampleDatabase server is running.
In an operational system the output could be quite extensive.</p>
<p>
Once the location of a server is known the list of channel names can be shown by asking for either
the GUID or tcp address.
Thus either:</p>
<pre>
pvlist 0x7F06B2560000000047B97D25
</pre>
or
<pre>
pvlist 10.0.0.37:45345
</pre>
produces:
<pre>
DBRao01
DBRdouble00
...
</pre>

<h3>pvget</h3>
<p>pvget provides functionality similar to caget.
For example:</p>
<pre>
mrk> caget DBRdouble01
double01                       0
mrk> pvget DBRdouble01
double01                       0
</pre>
<p>The options are:</p>
<pre>
mrk> pvget -help

Usage: pvget [options] PVname...

  -h Help: Print this message
options:
  -r pvrequest       Request, specifies what fields to return and options, default is 'field(value)'
  -w sec             Wait time, specifies timeout, default is 3.000000 second(s)
  -t                 Terse mode - print only value, without names
  -i                 Do not format standard types (enum_t, time_t, ...)
  -m                 Monitor mode
  -p provider       Set default provider name, default is 'pva'
  -q                 Quiet mode, print only error messages
  -d                 Enable debug output
  -F ofs             Use ofs as an alternate output field separator
  -f input_file     Use input_file as an input that provides a list PV name(s) to be read, use '-' for stdin
  -c                 Wait for clean shutdown and report used instance count (for expert users)
 enum format:
  -n  Force enum interpretation of values as numbers (default is enum string)

example: pvget double01
</pre>
<p>Some examples are:</p>
<pre>
mrk> pvget PVRenum01
PVRenum01                         zero
mrk> pvget -i PVRenum01
enum01
epics:nt/NTEnum:1.0 
    enum_t value
        int index 0
        string[] choices [zero,one,two,three]


mrk> pvget -i -r "value,alarm,timeStamp" enum01
PVRenum01
epics:nt/NTEnum:1.0 
    enum_t value
        int index 0
        string[] choices [zero,one,two,three]
    alarm_t alarm
        int severity 3
        int status 0
        string message UDF
    time_t timeStamp
        long secondsPastEpoch 631152000
        int nanoseconds 0
        int userTag 0
</pre>
<p>Multiple channels can be accessed witn a single command. For example:</p>
<pre>
mrk> pvget PVRdouble01 PVRdouble02
PVRdouble01                       0
PVRdouble02                       0
</pre>
<p>The above examples all use channel provider pva, i. e. the pvAccess server for network
communication.
It is also possible to use ca, i. e. the channel access server that comes with iocCore.
Thus it can access a V3 IOC even if the IOC has no V4 support.
</p>
<pre>
mrk> pvget -p ca DBRdouble01
DBRdouble01                       0
mrk> pvget -p ca -r "value,alarm,timeStamp" DBRdouble01
DBRdouble01
epics:nt/NTScalar:1.0 
    double value 0
    alarm_t alarm INVALID RECORD UDF_ALARM
    time_t timeStamp &lt;undefined&gt; 0
</pre>
<p>pvget can also monitor, i. e. it has functionality similer to camonitor.</p>
<pre>
mrk> pvget -m -r "value,alarm,timeStamp" PVRdouble02
PVRdouble02
epics:nt/NTScalar:1.0 
    double value 0
    alarm_t alarm INVALID NO_STATUS UDF
    time_t timeStamp &lt;undefine&gt; 0


PVRdouble02
epics:nt/NTScalar:1.0 
    double value 1
    alarm_t alarm NO_ALARM NO_STATUS NO_ALARM
    time_t timeStamp 2015-05-14T08:29:55.769 0
</pre>

<h3>pvput</h3>
<p>pvput provides functionality similar to caput.
For example:</p>
<pre>
mrk> caput DBRdouble01 1.0
Old : DBRdouble01                       1
New : DBRdouble01                       1
mrk> pvput DBRdouble01 1.0
Old : DBRdouble01                       1
New : DBRdouble01                       1
</pre>
<p>The options are:</p>
<pre>
mrk> pvput -help

Usage: pvput [options] PVname values...

  -h Help: Print this message
options:
  -r pv_request      Request, specifies what fields to return and options, default is 'field(value)'
  -w sec             Wait time, specifies timeout, default is 3.000000 second(s)
  -t                 Terse mode - print only successfully written value, without names
  -p provider        Set provider name, default is 'pva'
  -q                 Quiet mode, print only error messages
  -d                 Enable debug output
  -F ofs             Use ofs as an alternate output field separator
  -f input_file      Use input_file as an input that provides a list PV name(s) to be read, use '-' for stdin
 enum format:
  default Auto - try value as enum string, then as index number
  -n  Force enum interpretation of values as numbers
  -s  Force enum interpretation of values as strings

example: pvput double01 1.234
</pre>
<p>At the present time it is not possible to send output to multiple
channels with one command.
</p>
<h3>eget</h3>
<p>eget provides many of the same features but in addition supports
channelRPC and understands some of the normative types.
</p>
<p>The options are:</p>
<pre>
mrk> eget -h

Usage: eget [options] [PV_name ... | -s service_name]

  -h  Help: Print this message

options:
  -s service_name      Service API compliant based RPC service name (accepts NTURI request argument)
  -a service_arg       Service argument in 'name[=value]' or 'name value' form
  -r request           Get request string, specifies what fields to return and options, default is 'field(value)'
  -w sec               Wait time, specifies timeout, default is 3.000000 second(s)
  -z                   Pure pvAccess RPC based service (send NTURI.query as request argument)
  -N                   Do not format NT types, dump structure instead
  -i                   Do not format standard types (enum_t, time_t, ...)
  -t                   Terse mode
  -T                   Transpose vector, table, matrix
  -m                   Monitor mode
  -x                   Use column-major order to decode matrix
  -p provider          Set provider name, default is 'pva'
  -q                   Quiet mode, print only error messages
  -d                   Enable debug output
  -F ofs               Use ofs as an alternate output field separator
  -f input_file        Use input_file as an input that provides a list PV name(s) to be read, use '-' for stdin
  -c                   Wait for clean shutdown and report used instance count (for expert users)
 enum format:
  -n  Force enum interpretation of values as numbers (default is enum string)


examples:

#! Get the value of the PV corr:li32:53:bdes
> eget corr:li32:53:bdes

#! Get the table of all correctors from the rdb service
> eget -s rdbService -a entity=swissfel:devicenames

#! Get the archive history of quad45:bdes;history between 2 times, from the archive service
> eget -s archiveService -a entity=quad45:bdes;history -a starttime=2012-02-12T10:04:56 -a endtime=2012-02-01T10:04:56

#! Get polynomials for bunch of quads using a stdin to give a list of PV names
> eget -s names -a pattern=QUAD:LTU1:8%:POLYCOEF | eget -f -
</pre>

<h2>Channel Provider Context</h2>
<p>A channel provider normally has "context" associated with it.
For example the client side of provider <b>pva</b> needs threads for broadcasts,
connecting to a channel, and passing data between client and server.
This section discusses how existing providers are initialized so that a provider can create it's context.
</p>
<p>If <b>pvaClient</b> is used by a client it helps with initiatizing required providers.
This section discusses client provider initialization via pvaClient.
</p>
<p>
If pvDatabase implements and registers server provider <b>local</b>.
This section discusses server provider initialization via pvDatabase.
</p>
<h3>Fundamental Rules For Initializing Provider Context</h3>
<h4>Client Providers</h4>
<p>A client should only initialize the client providers it uses.
Since each provider can have overhead associated with it's context,
A client should not be started unless it is actually used.</p>
<h4>Server Providers</h4>
<p>The remote side of <b>pva</b> is started via a call to:</p>
<pre>
startPVAServer("providerList",...
</pre>
<p><b>providerList</b> should only include the server providers required.
and each provider must have registered with <b>channelProviderRegistry</b>
before <b>startPVAServer</b> is called.
</p>
<p>
In particular the list should not include any client providers or network loops may occur.
</p>
<h3>Context Initialization via pvaClient</h3>
<p><b>PvaClient</b> is a singleton class.
It initializes client providers, can cache channel connections, and some other channel methods.
</p>
<p>A C++ client starts pvaClient via:</p>
<pre>
PvaClientPtr pva= PvaClient::get("providerList");
</pre>
<p>A Java client starts pvaClient via:</p>
<pre>
PvaClient pva= PvaClient.get("providerList");
</pre>
<p><b>providerList</b> is a space separated list of provider names.
If this is called by a pure client the the only currently supported options are:</p>
<dl>
   <dt>"pva"</dt>
     <dd>The context for the client side of provider <b>pva</b> is started.</dd>
   <dt>"ca"</dt>
     <dd>The context for the client side of provider <b>ca</b> is started.</dd>
   <dt>"pva ca"</dt>
     <dd>The context for the client side of provider <b>pva</b> and <b>ca</b> are started.</dd>
</dl>
<p>Other client providers can also be implemented but each must call provide a method to
initialize it's context and each must register itself before PvaClient is started.
</p>
<p>
It is also possible for PvaClient to be used in a server to access other channels.
An example is a PVRecord that has a link to another channel.
In this case the <b>providerList</b> can also include service providers,
but the service providers must have registered with <b>channelProviderRegistry</b>
before PvaClient is started.
</p>
<h3>Server Context Initialization</h3>
<p>Both Java and C++ implement a pvAccess method named <b>startPVAServer</b>,
which starts the server context for the remote side of provider <b>pva</b>.
The first argument to this method is a string that has a space separated list
of provider names.
Each provider must be  registered with  <b>channelProviderRegistry</b> before <b>startPVAServer</b> is called.
</p>
<p><b>pvDatabase</b> implements a provider named <b>local</b>,
which is a provider that accesses PVRecords.
</p>
<p><b>pvaSrv</b> implements provider <b>dbPv</b>,
which is a provider for accessing V3 DBRecords.
This is only available for a V3 IOC.
</p>
<p>Other server providers can also be provided but each must register with <b>channelProviderRegistry</b> before <b>startPVAServer</b> is called.
</p>
<p>In Java the context for the remote side of provider <b>pva</b> is started via:</p>
<pre>
ServerContextImpl context = ServerContextImpl.("local",0,true,System.out);
</pre>
<p>In C++ a server that is not part of a V3 IOC, the context for the remote side of provider. <b>pva</b> is started via:</p>
<pre>
ServerContextImpl context = ServerContextImpl.startPVAServer("local",0,true,System.out);
</pre>
<p>In C++ a server that is part of a V3 IOC, the context for the remote side of provider
is started via the following statement in a st.cmd file.</p>
<pre>
startPVAServer "local dbPv"
</pre>

<h2>example code</h2>

<p><b>exampleCPP</b> and <b>exampleJava</b> both have examples that use code from all modules
described in this document except for <b>pvaPy</b>.
In particular they both have examples:</p>
<dl>
    <dt>database</dt>
       <dd>
         Example server code implemented via pvDatabase.<br />
         In addition it shows how to have PVRecords and V3 Records both running as part of a V3 IOC.
         <br />
         It also shows how to start provider <b>dbPv</b> so that both <b>ca</b> and <b>pva</b>
         can be used to access the V3 records.
       </dd>
    <dt>exampleClient</dt>
        <dd>
          example client code using the API for pvaClient
       </dd>
    <dt>exampleLink</dt>
        <dd>
        Implements PVRecords that monitor, get, and put to channel.<br />
        For now the other channel must exists or initialization fails.
        </dd>
</dl>
<p>These examples that can be used while learning what is described in this document.
Both exampleJava and exampleCPP have other examples.
</p>

<p>Examples in <b>exampleJava/exampleClient</b>, <b>exampleCPP/exampleClient</b>, and <b>pvaPy</b> require that the database in <b>exampleCPP/exampleClient</b> 
or <b>exampleJava/exampleClient</b> 
is started.
If exampleCPP is used the exampleDatabase can be started either as a main
program or as part of a V3 IOC.
If started as part of a V3 IOC, it also has V3 records and starts <b>pvaSrv</b>.
If started as a main program the result is the same as starting <b>exampleJava/database</b>
All the V4 PVRecords have the prefix <b>PVR</b> and all the V3 DBRecords have the prefix
<b>DBR</b>.
</p>
<p>
In linux <b>exampleCPP/database</b> can be started as follows:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/database/iocBoot/exampleDatabase
mrk> ../../bin/linux-x86_64/exampleDatabase st.cmd
</pre>
<p>The example database has both V3 IOC records and V4 PVRecords.
In addition <b>pvaSrv</b> is running. Thus all V3 records are available via either <b>ca</b> or <b>pva</b>.
The PVRecords are only available via <b>pva</b>.
Examples of using ca and pva command line tools are:</p>
<pre>
mrk> pvlist 
GUID 0x7F06B2560000000047B97D25, version 1: tcp@[10.0.0.37:45345, 192.168.124.1:45345]
mrk> pvlist 0x7F06B2560000000047B97D25
DBRao01
DBRdouble00
.... many more records
mrk> pvget PVRlong
Channel connect timed out: 'PVRlong' not found.
PVRlong                        0
mrk> caget PVRlong
mrk> caget DBRdouble01
DBRdouble01                       0
mrk> pvget DBRdouble01
DBRdouble01                       0
mrk> caget PVRushort01
Channel connect timed out: 'PVRushort01' not found.
mrk> pvget PVRushort01
PVRushort01                       0
mrk> 
</pre>
<p>The examples in <b>exampleCPP/exampleClient</b> and <b>exampleJava/exampleClient</b> can now be run.
For example:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleClient
mrk> ls bin/linux-x86_64/
examplePvaClientGet          examplePvaClientNTMulti  helloWorldPutGet
examplePvaClientMonitor      examplePvaClientProcess  helloWorldRPC
examplePvaClientMultiDouble  examplePvaClientPut

mrk> bin/linux-x86_64/examplePvaClientGet
_____examplePvaClientGet starting_______
__exampleDouble__
short way
as double 0
long way
as double 0
... LOTS MORE OUTPUT

</pre>
<p>An example of running the examples in pvaPy is:</p>
<pre>
mrk> pwd
/home/epicsv4/pvaPy/examples
mrk> python testPut.py
****************************
Testing string
Got old value:  
Putting value:  ; a
Got new value:  ; a
Putting value:  ; b
Got new value:  ; b

...... lots more output
mrk>
</pre>


<h2>API: pvData</h2>
<h3>ScalarType</h3>
<p>This defines the pvData primitive types:</p>
<dl>
 <dt>boolean</dt>
    <dd>Can be either <b>true</b> or <b>false</b>
    </dd>
  <dt>byte</dt>
     <dd>
     An 8 bit signed integer.
     </dd>
  <dt>short</dt>
     <dd>
     A 16 bit signed integer.
     </dd>
  <dt>int</dt>
     <dd>
     A 32 bit signed integer.
     </dd>
  <dt>long</dt>
     <dd>
     A 64 bit signed integer.
     </dd>
  <dt>ubyte</dt>
     <dd>
     An 8 bit unsigned integer.
     </dd>
  <dt>ushort</dt>
     <dd>
     A 16 bit unsigned integer.
     </dd>
  <dt>uint</dt>
     <dd>
     A 32 bit unsigned integer.
     </dd>
  <dt>ulong</dt>
     <dd>
     A 64 bit unsigned integer.
     </dd>
  <dt>float</dt>
     <dd>
     A 32 bit IEEE floating point number.
     </dd>
  <dt>double</dt>
     <dd>
     A 64 bit IEEE floating point number.
     </dd>
  <dt>string</dt>
     <dd>
      In Java a Java String. In C++ a std::string.
      On the network a UTF8 encoded string.
     </dd>
</dl>
<h3>Type</h3>
<p>A pvData object consists of a set of fields where each field has one on the following types:</p>
<dl>
   <dt>scalar</dt>
      <dd>
        The type of the field is one of the scalar types.
      </dd>
   <dt>scalarArray</dt>
      <dd>
        The type of the field is an array one of the scalar types.
      </dd>
   <dt>structure</dt>
      <dd>
        The field has a set of sub-fields.
        Each sub-field has a name and a type that can be any valid Type.
      </dd>
   <dt>structureArray</dt>
      <dd>
       The  field is an array of structure fields where each
       element has the same introspection interface.
      </dd>
   <dt>union</dt>
      <dd>
       The field has a single sub-field.
       Two types of union are supported: a restricted union and a variant
       union. For a variant union the sub-field can be have any valid Type.
      For a restricted union the sub-field can have any of a specified
      set of Types.
      </dd>
   <dt>unionArray</dt>
      <dd>
       The  field is an array of union fields where each
       element has the same introspection interface.
      </dd>
</dl>
<h3>Data Examples</h3>
<p><b>NOTE:</b>
In the examples <b>alarm_t</b>, <b>time_t</b>, and <b>enum_t</b>
are used as type names.
All have type <b>structure</b>.
They are examples of special fields described later.
</p>
<p>The following is a top level structure that has three sub-fields:</p>
<dl>
   <dt>value</dt>
       <dd>This has type scalar and scalarType double.</dd>
   <dt>alarm</dt>
      <dd>This is a structure field.</dd>
   <dt>timeStamp</dt>
     <dd>This is also a structure field</dd>
</dl>
<pre>
structure
    double value 5.0
    alarm_t alarm
        int severity 0
        int status 0
        string message no alarm
    time_t timeStamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0
</pre>
<p>The following is an example where the value field is a scalar string array.</p>
<pre>
structure
    string[] value ["aaa","bbb","ccc","ddd"]
    time_t timeStamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0
</pre>
<p>The following example is a structure with a single subfield that is itself a structure.</p>
<pre>
structure
    enum_t value
        int index 0
        string[] choices [true,false]
</pre>
<p>The following has two examples of a restricted union.
</p>
<pre>
structure
    union value
        time_t
            long secondsPastEpoch 1000
            int nanoseconds 0
            int userTag 0

structure
    union value
        double  100000
</pre>
<p>This is like the previous example but now the value
field is a variant union.</p>
<pre>
structure
    any value
        time_t
            long secondsPastEpoch 1000
            int nanoseconds 0
            int userTag 0

structure
    any value
        double  100000
</pre>
<p>The first example is a union array where each element is variant union.
The second is where each element is a restricted union.
</p>
<pre>
structure
    any[] value
        any
            (none)
        any
            double  1.245
`
structure
    union[] value
        union
            (none)
        union
            double  1.245
</pre>
<p>This is a structure array where each element is a
<b>time_t</b> structure.
</p>
<pre>
structure
    time_t[] value
        time_t
            long secondsPastEpoch 1000
            int nanoseconds 0
            int userTag 0
        time_t
            long secondsPastEpoch 3000
            int nanoseconds 0
            int userTag 0
</pre>
<p>This is a structure that has data for a power supply.</p>
<pre>
structure
    alarm_t alarm
        int severity 0
        int status 0
        string message
    time_t timestamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0
    structure power
        double value 0
        alarm_t alarm
            int severity 0
            int status 0
            string message
    structure voltage
        double value 0
        alarm_t alarm
            int severity 0
            int status 0
            string message
    structure current
        double value 0
        alarm_t alarm
            int severity 0
            int status 0
            string message
</pre>


<h3>Introspection API</h3>
<pre>
Field
    string getID()
    Type getType()
    serialize/deserialize
    display

    Scalar
        ScalarType getScalarType()

    Union
        size_t getNumberFields()
        Field getField(string fieldName)
        size_t getFieldIndex(string fieldName)
        Field[] getFields()
        Field getField(size_t fieldIndex)
        string[] getFieldNames()
        string getFieldName(size_t fieldIndex)
        boolean isVariant()

        Array
            ArraySizeType getArraySizeType()
            size_t getMaximumCapacity()

        ScalarArray
            ScalarType getElementType()

        StructureArray
            Structure getStructure()

        UnionArray
            Union getUnion()

     Structure
         size_t getNumberFields()
         Field getField(string fieldName)
         Field getField(size_t fieldIndex)
         size_t getFieldIndex(string fieldName)
         Field[] getFields()
         string[] getFieldNames()
         string getFieldName(size_t fieldIndex)
</pre>
<h4>Field</h4>
<p>This is the base class for the Introspection API.
It has the members:</p>
<dl>
   <dt>string getID()</dt>
     <dd>
     Each field instance has an asociated ID, which is just a string.
     The core part of pvData and pvAccess do not attach any semantics
      to the value except that pvAccess transfers the ID when it
      transfers an introspection object.
    FieldCreate assigns a default ID to each type but also allows
    code to assign different values.
    This feature is used for both special fields and normative
    types.
     </dd>
   <dt>Type getType()</dt>
     <dd>
       Get the type.
     </dd>
   <dt>serialize/deserialize</dt>
     <dd>
       These are methods to convert an introspection object to/from a 
       byte stream. These are used by pvAccess to transfer introspection
       objects between client and server.
       Other code could also use these methods.
      This document does not provide the details.
      See pvDataCPP or pvDataJava for details.
     </dd>
   <dt>display</dt>
     <dd>
       These methods are used to display the value of an introspection
       object. Java provides <b>toString</b> methods.
      C++ provides C++ <b>steam</b> methods. 
      See pvDataCPP or pvDataJava for details.
     </dd>
</dl>
<h4>Scalar</h4>
<p>This is the API for type scalar.
It has a single method:</p>
<dl>
   <dt>ScalarType getScalarType()</dt>
     <dd>
      Return the scalarType
      </dd>
</dl>
<h4>Union</h4>
<p>This is the API for type union.
A union is a field that has a single subField.
The subField has no name.
A union can be either a variant union or a restricted union.
The subField for a variant union can have any supported type.
A restricted union has a Field array and a string array.
Each element of the string array is associated with the corresponding
element of the field array.</p>
<p>Union has the methods:</p>
<dl>
   <dt>size_t getNumberFields()</dt>
     <dd>Return the number of elements in the Field and string arrays.
      This is always 0 for a variant union.
     </dd>
   <dt>Field getField(string fieldName)</dt>
     <dd>
      Return the Field associated with the fieldName.
      A null Field is returned if the fieldName is not valid.
      For a variant array null is always returned.
     </dd>
   <dt>size_t getFieldIndex(string fieldName)</dt>
     <dd>
      Return the index associated with the fieldName.
      -1 is returned if the fieldName is not valid.
      For a variant array -1 is always returned.
     </dd>
   <dt>Field[] getFields()</dt>
     <dd>
      Get the field types.
      For a variant array and empty array is returned.
     </dd>
   <dt>Field getField(size_t fieldIndex)</dt>
     <dd>
       Get the introspection interface associates with the fieldIndex.
       A null Field is returned if the fieldIndex is not valid.
      For a variant array null is always returned.
     </dd>
   <dt>string[] getFieldNames()</dt>
     <dd>
      Get the field names.
      For a variant array and empty array is returned.
     </dd>
   <dt>string getFieldName(size_t fieldIndex)</dt>
     <dd>
      Get the name asociated with the fieldIndex.
      An empty string is returned if the fieldIndex is not valid.
      For a variant array an empty string is always returned.
     </dd>
   <dt>boolean isVariant()</dt>
     <dd>
      returns (false,true) if (restricted, variant) union.
     </dd>
</dl>
<h4>Array</h4>
<p>Base class for all array types. It has the methods:</p>
<dl>
   <dt>ArraySizeType getArraySizeType()</dt>
     <dd>
     Size means the number of elements.
     ArraySizeType is one of:
        <dl>
           <dt>variable</dt>
              <dd>The size is only limited by what cpu architecture allows.</dd>
           <dt>fixed</dt>
               <dd>The size is determined when an instance is created and can not be changed.</dd>
           <dt>bounded</dt>
               <dd>The size can be changed but only up to a maximum specified when an instance is created.</dd>
        </dl>
     </dd>
    <dt>size_t getMaximumCapacity()</dt>
     <dd>
       Get the maximum capacity and also size that array can have.
     </dd>
</dl>
<h4>ScalarArray</h4>
<p>This is the API for type scalarArray. It has the method:</p>
<dl>
   <dt>ScalarType getElementType()</dt>
     <dd>
      Get the ScalarType for each element.
     </dd>
</dl>
<h4>StructureArray</h4>
<p>This is the API for type structureArray. It has the method:</p>
<dl>
   <dt>Structure getStructure()</dt>
     <dd>
       Get the introspection interface that each element must have.
       Note that all elements MUST have exactly the same introspection interface.
     </dd>
</dl>
<h4>UnionArray</h4>
<p>This is the API for type unionArray. It has the method:</p>
<dl>
   <dt>Union getUnion()</dt>
     <dd>
       Get the introspection interface that each element must have.
       Note that all elements MUST have exactly the same introspection interface.
     </dd>
</dl>
<h4>Structure</h4>
<p>This is the API for type structure. It has the methods:</p>
<dl>
   <dt>getNumberFields</dt>
     <dd>Get the number of immediate sub-field in the structure.
     -1 is returned if the structure does not have any fields.
     </dd>
   <dt>Field getField(string fieldName)</dt>
     <dd>
     Get the subField with the specified name.
     A null Field is returned if the structure does not have a subField with the specified name.
     </dd>
   <dt>size_t getFieldIndex(string fieldName)</dt>
     <dd>
     Get the index of the subField with the specified name.
     -1 is returned if the structure does not have a subField with the specified name.
     </dd>
   <dt>Field[] getFields()</dt>
     <dd>
      Get the Field array for the subFields of the structure.
     </dd>
   <dt>Field getField(size_t fieldIndex)</dt>
     <dd>
     Get the subField with the specified index.
     A null Field is returned if the fieldIndex is invalid for this structure.
     </dd>
   <dt>string[] getFieldNames()</dt>
     <dd>
      Get fieldName array for the subFields.
     </dd>
    <dt>string getFieldName(size_t fieldIndex)</dt>
     <dd>
     Get the subField name with the specified index.
     An empty string is returned if the fieldIndex is invalid for this structure.
     </dd>
</dl>

<h3>Introspection Factory</h3>
<p>FieldBuilder is the easiest way to create introspection objects.
It calls methods in <b>FieldCreate</b>.
</p>
<p>
<b>NOTE:</b> Unless there is a compelling need then You should always use FieldBuilder
rather then calling methods in FieldCreate.
</p>
<pre>
FieldBuilder
    FieldBuilder setId(string id)
    FieldBuilder add(string name, ScalarType scalarType)
    FieldBuilder addBoundedString(string name, size_t maxLength)
    FieldBuilder add(string name, Field field)
    FieldBuilder addArray(string name, ScalarType scalarType)
    FieldBuilder addFixedArray(string name, ScalarType scalarType, size_t size)
    FieldBuilder addBoundedArray(string name, ScalarType scalarType, size_t bound)
    FieldBuilder addArray(string name, Field field)
    Structure createStructure()
    Union createUnion()
    FieldBuilder addNestedStructure(string name)
    FieldBuilder addNestedUnion(string name)
    FieldBuilder addNestedStructureArray(string name)
    FieldBuilder addNestedUnionArray(string name)
    FieldBuilder endNested()
</pre>
<p>FieldCreate is a factory for creating introspection objects.</p>
<pre>
FieldCreate
    static FieldBuilder createFieldBuilder()
    Scalar createScalar(ScalarType scalarType)
    BoundedString createBoundedString(size_t maxLength)
    ScalarArray createScalarArray(ScalarType elementType)
    ScalarArray createFixedScalarArray(ScalarType elementType, size_t size)
    ScalarArray createBoundedScalarArray(ScalarType elementType, size_t bound)
    Structure createStructure() //Java does not implement
    Structure createStructure(Structure structToClone) // CPP does not implement
    Structure createStructure(string[] fieldNames, Field[] fields)
    Structure createStructure(string id, string[] fieldNames, Field[] fields)
    StructureArray createStructureArray(Structure elementStructure)
    Union createVariantUnion()
    Union createUnion(string[] fieldNames, Field[] fields)
    Union createUnion(string id, string[] fieldNames, Field[] fields)
    UnionArray createUnionArray(Union elementUnion)
    UnionArray createVariantUnionArray()
    Structure appendField(Structure structure,string fieldName, Field field)
    Structure appendFields(Structure structure,string[] fieldNames, Field[] fields)
</pre>


<h4>FieldBuilder</h4>
<p>This is an easy way to create introspection interfaces.
A single instance can be used to create multiple introspection interfaces because
everytime createStructure or createUnion is called the internal state is reset to start over.
Each method except createStructure and createUnion return the FieldBuilder itself so that
methods can be chained together. See the examples below.
The methods are:</p>
<dl>
    <dt>FieldBuilder setId(string id)</dt>
       <dd>
       Specify the ID for the next Structure or Union to create.
       </dd>
    <dt>FieldBuilder add(string name, ScalarType scalarType)</dt>
       <dd>
      Add a scalar field.
       </dd>
    <dt>FieldBuilder addBoundedString(string name, size_t maxLength)</dt>
       <dd>
        Add a bounded string field.
       </dd>
    <dt>FieldBuilder add(string name, Field field)</dt>
       <dd>
        Add a field with the specified type.
       </dd>
    <dt>FieldBuilder addArray(string name, ScalarType scalarType)</dt>
       <dd>
         Add a scalarArray with the specified element type.
       </dd>
    <dt>FieldBuilder addFixedArray(string name, ScalarType scalarType, size_t size)</dt>
       <dd>
         Add a fixed size scalarArray with the specified element type.
       </dd>
    <dt>FieldBuilder addBoundedArray(string name, ScalarType scalarType, size_t bound)</dt>
       <dd>
         Add a bounded size scalarArray with the specified element type.
       </dd>
    <dt>FieldBuilder addArray(string name, Field field)</dt>
       <dd>
        Add an array with elementType field.
       </dd>
    <dt>Structure createStructure()</dt>
       <dd>
        Create a Structure from what has been defined so far. The internal state is reset after creation.
       </dd>
    <dt>Union createUnion()</dt>
       <dd>
        Create a Union from what has been defined so far. The internal state is reset after creation.
       </dd>
    <dt>FieldBuilder addNestedStructure(string name)</dt>
       <dd>
        Add a nested Structure. All fields added until the corresponding endNested will be in the nested Structure.
       </dd>
    <dt>FieldBuilder addNestedUnion(string name)</dt>
       <dd>
        Add a nested Union. All field added until the corresponding endNested will be in the nested Union.
       </dd>
    <dt>FieldBuilder addNestedStructureArray(string name)</dt>
       <dd>
        Add a nested StructureArray.
        All fields added until the corresponding endNested will be in the nested StructureArray.
       </dd>
    <dt>FieldBuilder addNestedUnionArray(string name)</dt>
       <dd>
        Add a nested UnionArray.
        All fields added until the corresponding endNested will be in the nested UnionArray.
       </dd>
    <dt>FieldBuilder endNested()</dt>
       <dd>
        End of the current nested Structure, Union, StructureArray, or UnionArray.
       </dd>
</dl>
<h4>FieldCreate</h4>
<p>The methods are:</p>
<dl>
    <dt>FieldBuilder createFieldBuilder()</dt>
      <dd>
       Create a FieldBuilder which was described above.
      </dd>
    <dt>Scalar createScalar(ScalarType scalarType)</dt>
      <dd>
       Create a Scalar of the specified type.
      </dd>
    <dt>BoundedString createBoundedString(size_t maxLength)</dt>
      <dd>
        Create a BoundedString, which is a Scalar with ScalarType pvString and that has a bounded size.
      </dd>
    <dt>ScalarArray createScalarArray(ScalarType elementType)</dt>
      <dd>
       Create a ScalarArray that has elements of the specified ScalarType.
      </dd>
    <dt>ScalarArray createFixedScalarArray(ScalarType elementType, size_t size)</dt>
      <dd>
       Create a ScalarArray of the specified ScalarType and that will have the specified fixed size.
      </dd>
    <dt>ScalarArray createBoundedScalarArray(ScalarType elementType, size_t bound)</dt>
      <dd>
       Create a ScalarArray of the specified ScalarType and that will have the specified maximum size.
      </dd>
    <dt>Structure createStructure() //Java does not implement</dt>
      <dd>
       Create a Structure with no subFields.
      </dd>
   <dt>Structure createStructure(Structure structToClone) // CPP does not implement</dt>
      <dd>
        Create a new Structure that is a clone of an existing structure.
      </dd>
    <dt>Structure createStructure(string[] fieldNames, Field[] fields)</dt>
      <dd>
       Create a Structure with the specified set of fieldNames and fields.
       The length of the two arrays must be the same.
      </dd>
    <dt>Structure createStructure(string id, string[] fieldNames, Field[] fields)</dt>
      <dd>
       Create a Structure with the specified set of fieldNames and fields.
       The length of the two arrays must be the same.
        The Structure will have the ID specfied.
      </dd>
    <dt>StructureArray createStructureArray(Structure elementStructure)</dt>
      <dd>
       Create a StructureArray where each element will have the specified introspection interface.
      </dd>
   <dt>Union createVariantUnion()</dt>
      <dd>
       Create a variant Union.
      </dd>
    <dt>Union createUnion(string[] fieldNames, Field[] fields)</dt>
      <dd>
        Create an restricted Union that can have a subField with one of the types specified by fields.
      </dd>
    <dt>Union createUnion(string id, string[] fieldNames, Field[] fields)</dt>
      <dd>
      Like the previous method but with the ID specified.
      </dd>
    <dt>UnionArray createUnionArray(Union elementUnion)</dt>
      <dd>
       Create a UnionArray where each element will have the specified introspection interface.
      </dd>
    <dt>UnionArray createVariantUnionArray()</dt>
      <dd>
       Create a UnionArray where each element can have any valid type.
      </dd>
    <dt>Structure appendField(Structure structure,string fieldName, Field field)</dt>
      <dd>
        Create a new Structure that is the old structure with an appended subField.
      </dd>
    <dt>Structure appendFields(Structure structure,string[] fieldNames, Field[] fields)</dt>
      <dd>
        Create a new Structure that is the old structure with appended subFields.
      </dd>
    
    
</dl>


<h3>Data API</h3>
<pre>
PVField
    serialize/deserialize
    display
    string getFieldName()
    string getFullName()
    size_t getFieldOffset()
    size_t getNextFieldOffset()
    size_t getNumberFields()
    boolean isImmutable()
    void setImmutable()
    Field getField()
    PVStructure getParent()
    void postPut()
    void setPostHandler(PostHandler postHandler)

    PVScalar
        Scalar getScalar()

        PVScalarType // each scalarType, e. g. PVBoolean
            scalarType get()
            void put (scalarType value)

    PVUnion
        Union getUnion()
        PVField get()
        PVType get(Class c)           //PVType is valid PVField extension
        PVField select(int index)
        PVType select(Class c,int index)
        PVField select(string fieldName)
        PVType select(Class c,string fieldName)
        int getSelectedIndex()
        string getSelectedFieldName()
        void set(PVField value)
        void set(int index, PVField value)
        void set(string fieldName, PVField value)

    PVArray
        Array getArray()
        size_t getLength(
        void setLength(size_t length)
        size_t getCapacity(
        void setCapacity(size_t length)
        boolean isCapacityMutable()
        void setCapacityMutable(boolean isMutable)

        PVScalarArray
            ScalarArray getScalarArray()

            PVScalarTypeArray  // each scalarType, e.g. PVBooleanArray
                // C++ and Java have different semantics. See below

        PVUnionArray
            UnionArray getUnionArray()
            // C++ and Java have different semantics. See below

        PVStructureArray
            StructureArray getStructureArray()
            // C++ and Java have different semantics. See below.
</pre>
<h4>PVField</h4>
<dl>
   <dt>serialize/deserialize</dt>
     <dd>
       These are methods to convert a data object to/from a 
       byte stream. These are used by pvAccess to transfer data
       objects between client and server.
       Other code could also use these methods.
      This document does not provide the details.
      See pvDataCPP or pvDataJava for details.
     </dd>
   <dt>display</dt>
     <dd>
       These methods are used to display the value of a data
       object. Java provides <b>toString</b> methods.
      C++ provides <b>steam</b> methods.
      See pvDataCPP or pvDataJava for details.
     </dd>
   <dt>string getFieldName()</dt>
      <dd>
      Get the name of the field.
      The name of a top level field is an empty string.
      </dd>
   <dt>string getFullName()</dt>
      <dd>
       Fully expand the name of this field using the names of its parent fields with a dot '.' separating each name.
      For example if an alarm is a top level field named alarm then the
      status field has the name <b>alarm.status</b>.
      </dd>
    <dt>size_t getFieldOffset()</dt>
      <dd>
       Get offset of the PVField field within top level structure.
       Every field within the PVStructure has a unique offset.
       The top level structure has an offset of 0.
       The first field within the structure has offset equal to 1.
       The other offsets are determined by recursivelys
        traversing each structure of the tree.
      </dd>
    <dt>size_t getNextFieldOffset()</dt>
      <dd>
      Get the next offset.
      If the field is a scalar or union or array field
      then this is just offset + 1.
      If the field is a structure it is the offset
      of the next field after this structure.
      Thus (nextOffset - offset) is always equal
      to the number of fields within the field.
      </dd>
    <dt>size_t getNumberFields()</dt>
      <dd>
       Get the total number of fields in this field.
       This is equal to nextFieldOffset - fieldOffset.
      </dd>
    <dt>boolean isImmutable()</dt>
      <dd>
      Is the field immutable, i.e. does it not allow changes.
      </dd>
    <dt>void setImmutable()</dt>
      <dd>
       Set the field to be immutable, i. e. it can no longer be modified.
       This is permanent, i.e. once done the field can not be made mutable.
      </dd>
    <dt>Field getField()</dt>
      <dd>
       Get the <b>Field</b> that describes the field.
      </dd>
    <dt>PVStructure getParent()</dt>
      <dd>
       Get the parent of this field.
       A top level field has a null parent.
      </dd>
    <dt>void postPut()</dt>
      <dd>
      Called when the field is updated by the implementation.
      </dd>
    <dt>void setPostHandler(PostHandler postHandler)</dt>
      <dd>
      Set the handler for postPut. At most one handler can be set.
      </dd>
</dl>
<h4>PVScalar</h4>
<dl>
   <dt>Scalar getScalar()</dt>
      <dd>
       Get the <b>Scalar</b> that describes the field.
      </dd>
</dl>
<h4>PVScalarType // each scalarType, e. g. PVBoolean</h4>
<dl>
    <dt>scalarType get()</dt>
      <dd>
       Get the value.
      For example PVDouble has a method <b>double get()</b>.
      </dd>
    <dt>void put (scalarType value)</dt>
      <dd>
       Change the value.
      For example PVDouble has a method <b>void put(double value)</b>.
      </dd>
</dl>
<h4>PVUnion</h4>
<dl>
    <dt>Union getUnion()</dt>
      <dd>
       Get the <b>Union</b> that describes the field.
      </dd>
    <dt>PVField get()</dt>
      <dd>
       Get the current data member.
      This can be null.
      </dd>
    <dt>PVType get(Class c)</dt>
      <dd>
       Get the current data member.
       This returns null if no member or if current member is
       not of the type sepecified.
      </dd>
    <dt>PVField select(int index)</dt>
      <dd>
       If the union is a restricted union than select the
        field specified by index. If the curent field has a
       different type than a new field is created.
      An exception is thrown if the index is out of range
      or for a variant union.
      The interface to the data object is returned.
      </dd>
    <dt>PVType select(Class c,int index)</dt>
      <dd>
       Like the previous method but null is returned if the
       data object does not have the specified type.
      </dd>
    <dt>PVField select(string fieldName)</dt>
      <dd>
       If the union is a restricted union than select the
        field specified by fieldName. If the curent field has a
       different type than a new field is created.
      An exception is thrown if the fieldName is not valid
      or for a variant union.
      The interface to the data object is returned.
      </dd>
    <dt>PVType select(Class c,string fieldName)</dt>
      <dd>
       Like the previous method but null is returned if the
       data object does not have the specified type.
      </dd>
    <dt>int getSelectedIndex()</dt>
      <dd>
      Get the index of the current field.
     A -1 is returned if no field defined or for a variant union.
      </dd>
    <dt>string getSelectedFieldName()</dt>
      <dd>
       Get the fieldName of the current field.
       A null string is returned if no field defined or for a variant union.
      </dd>
    <dt>void set(PVField value)</dt>
      <dd>
       Set the data member to the specified value.
       An exception is thrown if the value is not valid for this PVUnion.
      </dd>
    <dt>void set(int index, PVField value)</dt>
      <dd>
       Set the data member to the specified index and value.
       An exception is thrown if the value is not valid for this index.
      </dd>
    <dt>void set(string fieldName, PVField value)</dt>
      <dd>
       Set the data member to the specified fieldName and value.
       An exception is thrown if the value is not valid for this fieldName.
      </dd>
</dl>

<h4>PVArray</h4>
<dl>
    <dt>Array getArray()</dt>
      <dd>
       Get the <b>Array</b> that describes the field.
      </dd>
    <dt>size_t getLength(</dt>
      <dd>
      Get the current length of the array.
      </dd>
    <dt>void setLength(size_t length)</dt>
      <dd>
       Set the length of the array.
       An exception is thrown if the value is not legal for this array.
      </dd>
    <dt>size_t getCapacity(</dt>
      <dd>
       Get the current capacity of the array.
      </dd>
    <dt>void setCapacity(size_t length)</dt>
      <dd>
        Set the capacity.
       An exception is thrown if the value is not legal for this array.
      </dd>
    <dt>boolean isCapacityMutable()</dt>
      <dd>
        Returns (true,false) if the capacity (can,can not) be changed.
      </dd>
    <dt>void setCapacityMutable(boolean isMutable)</dt>
      <dd>
       Set capacityMutable to the specified value.
      </dd>
</dl>

<h4>PVScalarArray</h4>
<p>Most methods are different for Java and C++. See following sections.</p>
<dl>
    <dt>ScalarArray getScalarArray()</dt>
      <dd>
       Get the <b>ScalarArray</b> that describes the field.
      </dd>
</dl>

<h4>PVUnionArray</h4>
<p>Most methods are different for Java and C++. See following sections.</p>
<dl>
    <dt>UnionArray getUnionArray()</dt>
      <dd>
       Get the <b>UnionArray</b> that describes the field.
      </dd>
</dl>

<h4>PVStructureArray</h4>
<p>Most methods are different for Java and C++. See following sections.</p>
<dl>
     <dt>StructureArray getStructureArray()</dt>
      <dd>
       Get the <b>StructureArray</b> that describes the field.
      </dd>
</dl>



<h3>Data Factory</h3>
<pre>
PVDataCreate
    PVField createPVField(Field field)
    PVField createPVField(PVField fieldToClone)
    PVScalar createPVScalar(Scalar scalar)
    PVScalar createPVScalar(ScalarType fieldType)
    PVScalar createPVScalar(PVScalar scalarToClone)
    PVScalarType createPVScalar(Class scalarType) // generic 
    PVUnion createPVUnion(Union union)
    PVUnion createPVVariantUnion()
    PVUnion createPVUnion(PVUnion unionToClone)
    PVStructure createPVStructure(Structure structure)
    PVStructure createPVStructure(string[] fieldNames,PVField[] pvFields)
    PVStructure createPVStructure(PVStructure structToClone)
    PVScalarArray createPVScalarArray(ScalarArray array)
    PVScalarArray createPVScalarArray(ScalarType elementType)
    PVScalarArray createPVScalarArray(PVScalarArray arrayToClone)
    PVScalarTypeArray createPVScalarArray(Class element) // generic 
    PVStructureArray createPVStructureArray(StructureArray structureArray)
    PVStructureArray createPVStructureArray(Struture structure)
    PVUnionArray createPVUnionArray(UnionArray unionArray)
    PVUnionArray createPVVariantUnionArray()
    PVUnionArray createPVUnionArray(Union union)
</pre>
where
<dl>
  <dt>PVField createPVField(Field field)</dt>
    <dd>
      Create a PVField with the specified introspection interface.
    </dd>
  <dt>PVField createPVField(PVField fieldToClone)</dt>
    <dd>
      Create a PVField with the same introspection interface as
      fieldToClone and then copy data from fieldToClone to newly
      created PVField.
    </dd>
  <dt>PVScalar createPVScalar(Scalar scalar)</dt>
    <dd>
      Create a PVScalar with the specified introspection interface.
    </dd>
  <dt>PVScalar createPVScalar(ScalarType fieldType)</dt>
    <dd>
      Create a PVScalar with the specified fieldType.
    </dd>
  <dt>PVScalar createPVScalar(PVScalar scalarToClone)</dt>
    <dd>
      Create a PVScalar with the same introspection interface as
      scalarToClone and then copy data from scalarToClone to newly
      created PVScalar.
    </dd>
  <dt>PVScalarType createPVScalar(Class scalarType)</dt>
    <dd>
     Generic version of createPVScalar.
     See pvDataJava or pvDataCPP for language specific syntax.
    </dd>
  <dt>PVUnion createPVUnion(Union union)</dt>
    <dd>
      Create a PVUnion with the specified introspection interface.
    </dd>
  <dt>PVUnion createPVVariantUnion()</dt>
    <dd>
      Create a variant PVUnion.
    </dd>
  <dt>PVUnion createPVUnion(PVUnion unionToClone)</dt>
    <dd>
      Create a PVUnion with the same introspection interface as
      unionToClone and then copy data from unionToClone to newly
      created PVUnion.
    </dd>
  <dt>PVStructure createPVStructure(Structure structure)</dt>
    <dd>
      Create a PVStructure with the specified introspection interface.
    </dd>
  <dt>PVStructure createPVStructure(string[] fieldNames,PVField[] pvFields)</dt>
    <dd>
      Create a PVStructure with the specified set of fieldNames.
      The introspection interface for the subFields is the same
      as the introspection interfaces of pvFields.
      <b>Why does this method exist?</b>
    </dd>
  <dt>PVStructure createPVStructure(PVStructure structToClone)</dt>
    <dd>
      Create a PVStructure with the same introspection interface as
      structToClone and then copy data from structToClone to newly
      created PVStructure.
    </dd>
  <dt>PVScalarArray createPVScalarArray(ScalarArray array)</dt>
    <dd>
      Create a PVScalarArray with the specified introspection interface.
    </dd>
  <dt>PVScalarArray createPVScalarArray(ScalarType elementType)</dt>
    <dd>
      Create a PVScalarArray with the specified elementType.
    </dd>
  <dt>PVScalarArray createPVScalarArray(PVScalarArray arrayToClone)</dt>
    <dd>
      Create a PVScalarArray with the same introspection interface as
      arrayToClone and then copy data from arrayToClone to newly
      created PVScalarArray.
    </dd>
  <dt>PVScalarTypeArray createPVScalarArray(Class element)</dt>
    <dd>
     Generic version.
     See pvDataJava or pvDataCPP for language specific syntax.
    </dd>
  <dt>PVStructureArray createPVStructureArray(StructureArray structureArray)</dt>
    <dd>
      Create a PVStructureArray with the specified introspection interface.
    </dd>
  <dt>PVStructureArray createPVStructureArray(Struture structure)</dt>
    <dd>
      Create a PVStructureArray where each element has
      the specified introspection interface.
    </dd>
  <dt>PVUnionArray createPVUnionArray(UnionArray unionArray)</dt>
    <dd>
      Create a PVUnionArray with the specified introspection interface.
    </dd>
  <dt>PVUnionArray createPVVariantUnionArray()</dt>
    <dd>
      Create a variant PVUnionArray.
    </dd>
  <dt>PVUnionArray createPVUnionArray(Union union)</dt>
    <dd>
      Create a PVUnionArray where each element has
      the specified introspection interface.
    </dd>
</dl>
<h3>Java Array API</h3>
<p>The following is for PVDoubleArray.
There are similar definitions for each scalarType.</p>
<pre>public class DoubleArrayData {
    public double[] data
    public int offset
}

interface PVDoubleArray extends PVArray {
    int get(int offset, int len, DoubleArrayData data)
    int put(int offset,int len, double[] from, int fromOffset)
    void shareData(double[] from)
}</pre>
<p>For PVStructureArray and PVUnionArray the definitions are:</p>
<pre>
public class StructureArrayData {
    public PVStructure[] data
    public int offset
}

interface PVStructureArray extends PVArray {
    StructureArray getStructureArray()
    int get(int offset, int length, StructureArrayData data)
    int put(int offset,int length, PVStructure[] from, int fromOffset)
    void shareData(PVStructure[] from)
}

public class UnionArrayData {
    public PVUnion[] data
    public int offset
}

interface PVUnionArray extends PVArray{
    UnionArray getUnionArray()
    int get(int offset, int length, UnionArrayData data)
    int put(int offset,int length, PVUnion[] from, int fromOffset)
    void shareData(PVUnion[] from)
}
</pre>
<h3>C++ Array API</h3>
<p>The C++ Array API inforces Copy On Write (COW) semantics.
The actual definition is template based.
But the following is the psuedo code for PVDoubleArray.
Each scalarType, PVUnionArray, and PVStructureArray have similar psuedo code.
</p>
<pre>
class PVDoubleArray
    ...
    shared_vector&lt;const double&gt; view()
    void swap(shared_vector&lt;const double&gt; other)
    void replace(const shared_vector&lt;const double&gt; next)
    shared_vector&lt;double&gt; reuse()
    ...
// to change the raw array use code like:
shared_vector&lt;double&gt; data(n)
// put values into data and then
pvDoubleArray->replace(freeze(data))
</pre>




<h3>BitSet and PVStructure</h3>
<p>Some important features of pvAccess are:</p>
<dl>
  <dt>PVAccess Transmits Top Level PVStructures</dt>
    <dd>
     For example a channelGet sends data from server to client as a top
     level PVStructure. For a channelPutGet a top level PVStructure
     is sent from the client to the server and a different top
     level PVStructure is returned from the server to the client.
     </dd>
  <dt>Top Level Introspection Immutable</dt>
     <dd>
     Once a top level PVStructure is created it's introspection
     can not be modified.
    Thus pvAccess has no need to send introspection information
    with data. Consider channelGet as an example.
    When a channelGet is created the server creates a top level
    pvStructure for get requests.
    The server sends the introspection info back to the client
    side of pvAccess, which also creates a top level pvStructure.
    Each time the client issues a get request the data is
    copied into the top level pvStructure of the server and
    transmitted to the client side of pvAccess,
    which puts the data in it's top level pvStructure.
    This is the data presented to the client.
     </dd>
  <dt>Only fields that change are transmitted.</dt>
    <dd>
      Only the data for fields that change value between requests
      are sent.
     </dd>
  <dt>Clients can request an arbitrary set of fields from server.</dt>
    <dd>
     The client does not have to receive all fields provided by the
     server but can request an arbitrary subset of the fields.
     </dd>
</dl>
<p>In order to implement the above features pvAccess uses bitSets,
where each bit is associated with a field.
The following is a top level pvStructure and how bits from a bitSet
are assigned:</p>
<a name="bitAssignment"></a>
<pre>
bit#    field
0    structure
1        double scalarValue
2        double[] scalarArrayValue
3        structure timeStamp
4            long secondsPastEpoch
5            int nanoSeconds
6            int userTag
7        union unionValue
             structure timeStamp
                 long secondsPastEpoch
                 int nanoSeconds
                 int userTag
8        structure[] structureValue
             structure timeStamp
                 long secondsPastEpoch
                 int nanoSeconds
                 int userTag
             structure timeStamp
                 long secondsPastEpoch
                 int nanoSeconds
                 int userTag
9        any[] unionValue
             any
                 structure timeStamp
                     long secondsPastEpoch
                     int nanoSeconds
                     int userTag
             any
                 double value
10       string lastValue
</pre>
<p>Note that bits for structure subfields are assigned recursively.
But each scalar, union, scalarArray, structureArray, and unionArray field
are assigned a single bit.
This means that each subfield of a union, structuctureArray, or unionArray
is treated just like a new top level field.
If ANY change is made to a union, scalarArray, structureArray,
or unionArray, the complete set of data for that field is sent.
</p>
<p>
Below the following are discussed:</p>
<dl>
  <dt>Convert</dt>
    <dd>A facility that supports copy and convert methods for PVData.
     </dd>
  <dt>pvCopy</dt>
     <dd>A facility that transfers data between a client top level
      PVStructure and the top level PVStructure from the server.
     </dd>
</dl>
<p>An important featured provided by Convert is to copy data between
compatible PVStructures.
</p>
<p>
<b>Java feature:</b>
pvDataJava does a deep copy of all fields 
with the possible exception of scalar array fields.
If the source and destination have the same scalarType
and the source is immutable then the raw data array is shared
and the destination is made immutable.
</p>
<p>
<b>C++ feature:</b>
pvDataCPP does deep copies between scalar and structure fields
but shallow copies between scalarArray, structureArray, and unionArray fields.
For scalarArray fields this is safe because the implementation of
arrays implements COW (Copy on Write) by making the array data <b>const</b>.
This forces code to create new raw data in order to change a scalar array
field.
It also uses <b>const</b> for structureArray and unionArray fields
but this does not force all elements of the array to be <b>const</b>.
Thus the elements can be changed.
Thus any code that wants to share a top level PVStructure
must be very careful when changing the value of a union,
structureArray, or unionArray field.
The rule is that the union, structureArray, or unionArray
must be replaced with a new value.
</p>
<p>Since the pvCopy facility makes extensive use of Convert
the same rules apply to it.</p>


<h2>pvDataCPP examples</h2>

<h3>C++ Introspection Basic Example</h3>
<p>The first example creates a Structure with a single subField:</p>

<h4>Using FieldBuilder</h4>

<pre>
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure =
    fb->add("value", pvDouble)->
    createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
<p>This produces:</p>
<pre>
structure
    double value
</pre>

<h4>Using FieldCreate the code is</h4>

<pre>
StringArray fieldName(1);
FieldConstPtrArray field(1);
fieldName[0] = "value";
field[0] = fieldCreate->createScalar(pvDouble);

StructureConstPtr structure =
    fieldCreate->createStructure(fieldName, field);
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
<p>This produces:</p>
<pre>
structure
    double value
</pre>

<h3>C++ Introspection More Complex Example</h3>
<p>The next example shows how to create a structure
that has three fields: a value field that is a scalarArray with
element type double, an alarm structure, and a timeStamp structure.
</p>
<p><b>NOTE:</b> Three different ways to create the same structure are shown.</p>

<h4>Using FieldBuilder and StandardField</h4>
<p><b>Prefered way!!</b>
This is the easiest way to create the example and also creates the
correct introspection interface for standard fields.</p>
<pre>
cout &lt;&lt; "valueAlarmTimeStamp\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StandardFieldPtr standardField = getStandardField();
StructureConstPtr structure  =
    fb->addArray("value", pvDouble)->
    add("alarm",standardField->alarm()))->
    add("timeStamp",standardField->timeStamp()))->
    createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
valueAlarmTimeStamp
structure
    double[] value
    alarm_t alarm
        int severity
        int status
        string message
    time_t timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>

<h4>Using FieldBuilder</h4>

<pre>
cout &lt;&lt; "valueAlarmTimeStamp\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr alarm =
   fb->add("severity", pvInt)->
   add("status",pvInt)->
   add("message",pvString)->
   createStructure();
StructureConstPtr timeStamp =
        fb->add("secondsPastEpoch", pvLong)->
        add("nanoseconds",pvInt)->
        add("userTag",pvInt)->
        createStructure();
StructureConstPtr structure  =
    fb->addArray("value", pvDouble)->
    add("alarm",alarm)->
    add("timeStamp",timeStamp)->
    createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
valueAlarmTimeStamp
structure
    double[] value
    structure alarm
        int severity
        int status
        string message
    structure timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>
<h4>Using FieldCreate</h4>
<pre>
size_t n = 3;
StringArray fieldName(n);
FieldConstPtrArray field(n);
fieldName[0] ="severity";
fieldName[1] ="status";
fieldName[2] ="message";
field[0] = fieldCreate->createScalar(pvInt);
field[1] = fieldCreate->createScalar(pvInt);
field[2] = fieldCreate->createScalar(pvString);
StructureConstPtr alarm = fieldCreate->createStructure(fieldName, field);
fieldName = StringArray(n);
field = FieldConstPtrArray(n);
fieldName[0] = "secondsPastEpoch";
fieldName[1] = "nanoseconds";
fieldName[2] = "userTag";
field[0] = fieldCreate->createScalar(pvLong);
field[1] = fieldCreate->createScalar(pvInt);
field[2] = fieldCreate->createScalar(pvInt);
StructureConstPtr timeStamp = fieldCreate->createStructure(fieldName, field);
fieldName = StringArray(n);
field = FieldConstPtrArray(n);
fieldName[0] = "value";
fieldName[1] = "alarm";
fieldName[2] = "timeStamp";
field[0] = fieldCreate->createScalarArray(pvDouble);
field[1] = alarm;
field[2] = timeStamp;
StructureConstPtr structure = fieldCreate->createStructure(fieldName, field);
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
structure
    double[] value
    structure alarm
        int severity
        int status
        string message
    structure timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>

<h3>More C++ Introspection Examples Using FieldBuilder</h3>
<dl>

   <dt>valueAlarmTimeStampNested</dt>
   <dd>
<pre>
cout &lt;&lt; "valueAlarmTimeStampNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addArray("value", pvDouble)->
    addNestedStructure("alarm")->
        add("severity", pvInt)->
        add("status",pvInt)->
        add("message",pvString)->
    endNested()->
    addNestedStructure("timeStamp")->
        add("secondsPastEpoch", pvLong)->
        add("nanoseconds",pvInt)->
        add("userTag",pvInt)->
        endNested()->
    createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
structure
    double[] value
    structure alarm
        int severity
        int status
        string message
    structure timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>
   </dd>

   <dt>union</dt>
    <dd>
<pre>
cout &lt;&lt; "union\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
UnionConstPtr unionx =
    fb->add("short", pvShort)->
    add("long", pvLong)->
    createUnion();
StructureConstPtr structure  =
    fb->add("value",unionx)->
        createStructure();
    cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
union
structure
    union value
        short short
        long long`
</pre>
    </dd>
   <dt>unionNested</dt>
   <dd>
<pre>
cout &lt;&lt; "unionNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addNestedUnion("value")->
        add("short", pvShort)->
        add("long", pvLong)->
        endNested()->
    createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces the same result as union.
   </dd>

   <dt>unionArray</dt>
   <dd>
<pre>
cout &lt;&lt; "unionArray\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
UnionConstPtr unionx =
    fb->add("short", pvShort)->
    add("long", pvLong)->
    createUnion();
StructureConstPtr structure  =
    fb->addArray("value",unionx)->
    createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
unionArray
structure
    union[] value
        union
            short short
            long long
</pre>
    </dd>

   <dt>unionArrayNested</dt>
   <dd>
<pre>
cout &lt;&lt; "unionArrayNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addNestedUnionArray("value")->
        add("short", pvShort)->
        add("long", pvLong)->
    endNested()->
        createStructure();
    cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces the same result as unionArray.
   </dd>

   <dt>structureArray</dt>
   <dd>
<pre>
cout &lt;&lt; "structureArray\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr subStruct =
    fb->add("short", pvShort)->
    add("long", pvLong)->
    createStructure();
StructureConstPtr structure  =
    fb->addArray("value",subStruct)->
createStructure();
cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces:
<pre>
structureArray
structure
structure[] value
        structure
            short short
            long long
</pre>
   </dd>

   <dt>structureArrayNested</dt>
   <dd>
<pre>
cout &lt;&lt; "structureArrayNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addNestedStructureArray("value")->
    add("short", pvShort)->
    add("long", pvLong)->
    endNested()->
        createStructure();
    cout &lt;&lt; structure &lt;&lt; endl;
</pre>
This produces the same result as structureArray.
   </dd>

</dl>

<h3>C++ Data Examples</h3>
<dl>
   <dt>simpleExample</dt>
    <dd>
<pre>
cout &lt;&lt; "simple\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->add("value", pvDouble)->
    createStructure();
PVStructurePtr pvStructure = pvDataCreate->createPVStructure(structure);
PVDoublePtr pvDouble = pvStructure->getSubField&lt;PVDouble&gt;( "value");
pvDouble->put(10.0);
cout &lt;&lt; pvStructure &lt;&lt; endl;
</pre>
    This produces:
<pre>
simple
structure 
    double value 10.0
</pre>
    </dd>
   <dt>valueAlarmTimeStamp</dt>
   <dd>
<pre>
cout &lt;&lt; "valueAlarmTimeStamp\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StandardFieldPtr standardField = getStandardField();
StructureConstPtr structure =
    fb->addArray("value", pvDouble)->
    add("alarm",standardField->alarm())->
    add("timeStamp",standardField->timeStamp())->
    createStructure();
PVStructurePtr pvStructure = pvDataCreate->createPVStructure(structure);
PVDoubleArrayPtr pvDoubleArray = pvStructure->getSubField&lt;PVDoubleArray&gt;("value");
size_t len = 4;
PVDoubleArray::svector data(4);
for(size_t i=0; i&lt;len; ++i) data[i] = i+1;
pvDoubleArray->replace(freeze(data));
    cout &lt;&lt; pvStructure &lt;&lt; endl;
</pre>
This produces:
<pre>
valueAlarmTimeStamp
structure 
    double[] value [1.0,2.0,3.0,4.0]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0
</pre>
   </dd>

   <dt>union</dt>
   <dd>
<pre>
cout &lt;&lt; "unionNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addNestedUnion("value")->
        add("short", pvShort)->
        add("long", pvLong)->
        endNested()->
    createStructure();
PVStructurePtr pvStructure = pvDataCreate->createPVStructure(structure);
PVLongPtr pvlong = pvDataCreate->createPVScalar&lt;PVLong&gt;();
pvlong->put(1000);
PVUnionPtr pvUnion = pvStructure->getSubField&lt;PVUnion&gt;("value");
pvUnion->set("long",pvlong);
    cout &lt;&lt; pvStructure &lt;&lt; endl;
</pre>
This produces:
<pre>
union
structure 
    union value
        long  1000
</pre>
    </dd>

   <dt>unionArray</dt>
    <dd>
<pre>
cout &lt;&lt; "unionArrayNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addNestedUnionArray("value")->
        add("short", pvShort)->
        add("long", pvLong)->
    endNested()->
    createStructure();
PVStructurePtr pvStructure = pvDataCreate->createPVStructure(structure);
PVUnionArrayPtr pvValue = pvStructure->getSubField&lt;PVUnionArray&gt;("value");
size_t len = 2;
PVUnionArray::svector pvUnions(len);
for(size_t i=0; i&lt;len; ++i) pvUnions[i] =
    pvDataCreate->createPVUnion(pvValue->getUnionArray()->getUnion());
pvUnions[0]->select("short");
pvUnions[1]->select("long");
PVShortPtr pvshort = pvUnions[0]->get&lt;PVShort&gt;();
pvshort->put(1);
PVLongPtr pvlong = pvUnions[1]->get&lt;PVLong&gt;();
pvlong->put(5);
pvValue->replace(freeze(pvUnions));
cout &lt;&lt; pvStructure &lt;&lt; endl;
</pre>
This produces:
<pre>
unionArray
structure 
    union[] value 
        union 
            short  1
        union 
            long  5
</pre>
    </dd>

   <dt>structureArray</dt>
   <dd>
<pre>
cout &lt;&lt; "structureArrayNested\n";
FieldBuilderPtr fb = fieldCreate->createFieldBuilder();
StructureConstPtr structure  =
    fb->addNestedStructureArray("value")->
        add("short", pvShort)->
        add("long", pvLong)->
    endNested()->
    createStructure();
PVStructurePtr pvStructure = pvDataCreate->createPVStructure(structure);
PVStructureArrayPtr pvValue = pvStructure->getSubField&lt;PVStructureArray&gt;("value");
size_t len = 2;
PVStructureArray::svector pvStructures(len);
for(size_t i=0; i&lt;len; ++i) {
    pvStructures[i] = pvDataCreate->createPVStructure(
        pvValue->getStructureArray()->getStructure());
    PVStructurePtr pvs = pvStructures[i];
    PVShortPtr pvshort = pvs->getSubField&lt;PVShort&gt;("short");
    pvshort->put(i);
    PVLongPtr pvlong = pvs->getSubField&lt;PVLong&gt;("long");
    pvlong->put(i);
}
pvValue->replace(freeze(pvStructures));
    cout &lt;&lt; pvStructure &lt;&lt; endl;
</pre>
This produces:
<pre>
structureArray
structure 
    structure[] value 
        structure 
            short short 0
            long long 0
        structure 
            short short 1
            long long 1
</pre>
   </dd>

   <dt>structureArray</dt>
   <dd>
<pre>
System.out.println("structureArray");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
   fb.addNestedStructureArray("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
    endNested().
    createStructure();
System.out.println(structure);`
</pre>
This produces the same result as structureArray.
   </dd>

</dl>

<h2>pvDataJava examples</h2>
<h3>Java Introspection Basic Example</h3>
<p>The first example creates a Structure with a single subField:</p>
<h4>Using FieldBuilder</h4>
<pre>
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
    fb.add("value", ScalarType.pvDouble).
    createStructure();
System.out.println(structure);
</pre>
<p>This produces:</p>
<pre>
structure
    double value
</pre>
<h4>Using FieldCreate</h4>
<pre>
String[] fieldName = new String[1];
Field[] field = new Field[1];
fieldName[0] = "value";
field[0] = fieldCreate.createScalar(ScalarType.pvDouble);
Structure structure = fieldCreate.createStructure(fieldName, field);
System.out.println(structure);
</pre>
<p>The output is again:</p>
<pre>
structure
    double value
</pre>
<h3>Java Introspection More Complex Example</h3>
<p>This example shows how to create a structure
that has three fields: a value field that is a scalarArray with
element type double, an alarm structure, and a timeStamp structure.</p>
<h4>Using FieldBuilder and StandardField</h4>
<pre>
System.out.println("valueAlarmTimeStamp");
FieldBuilder fb = fieldCreate.createFieldBuilder();
StandardField standardField = StandardFieldFactory.getStandardField();
Structure structure =
     fb.addArray("value", ScalarType.pvDouble).
     add("alarm",standardField.alarm()).
     add("timeStamp",standardField.timeStamp())).
     createStructure();
System.out.println(structure);
</pre>
This produces:
<pre>
valueAlarmTimeStamp
structure
    double[] value
    alarm_t alarm
        int severity
        int status
        string message
    time_t timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>

<h4>Using FieldBuilder</h4>
<pre>
System.out.println("valueAlarmTimeStamp");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure alarm =
     fb.add("severity", ScalarType.pvInt).
     add("status",ScalarType.pvInt).
     add("message",ScalarType.pvString).
     createStructure();
Structure timeStamp =
     fb.add("secondsPastEpoch", ScalarType.pvLong).
     add("nanoseconds",ScalarType.pvInt).
     add("userTag",ScalarType.pvInt).
     createStructure();
Structure structure =
     fb.addArray("value", ScalarType.pvDouble).
     add("alarm",alarm).
     add("timeStamp",timeStamp).
     createStructure();
System.out.println(structure);
</pre>
This produces:
<pre>
valueAlarmTimeStamp
structure
    double[] value
    structure alarm
        int severity
        int status
        string message
    structure timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>
<h4>Using FieldCreate</h4>
<pre>
String[] fieldName = new String[3];
Field[] field = new Field[3];
fieldName[0] ="severity";
fieldName[1] ="status";
fieldName[2] ="message";
field[0] = fieldCreate.createScalar(ScalarType.pvInt);
field[1] = fieldCreate.createScalar(ScalarType.pvInt);
field[2] = fieldCreate.createScalar(ScalarType.pvString);
Structure alarm = fieldCreate.createStructure(fieldName, field);
fieldName = new String[3];
field = new Field[3];
fieldName[0] = "secondsPastEpoch";
fieldName[1] = "nanoseconds";
fieldName[2] = "userTag";
field[0] = fieldCreate.createScalar(ScalarType.pvLong);
field[1] = fieldCreate.createScalar(ScalarType.pvInt);
field[2] = fieldCreate.createScalar(ScalarType.pvInt);
Structure timeStamp = fieldCreate.createStructure(fieldName, field);
fieldName = new String[3];
field = new Field[3];
fieldName[0] = "value";
fieldName[1] = "alarm";
fieldName[2] = "timeStamp";
field[0] = fieldCreate.createScalarArray(ScalarType.pvDouble);
field[1] = alarm;
field[2] = timeStamp;
Structure structure = fieldCreate.createStructure(fieldName, field);
System.out.println(structure);
</pre>
This produces:
<pre>
structure
    double[] value
    structure alarm
        int severity
        int status
        string message
    structure timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
</pre>

<h3>More Java Introspection Examples Using FieldBuilder</h3>
<dl>


   <dt>valueAlarmTimeStampNested</dt>
   <dd>
      <pre>
System.out.println("valueAlarmTimeStampNested");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure =
    fb.addArray("value", ScalarType.pvDouble).
    addNestedStructure("alarm").
         add("severity", ScalarType.pvInt).
         add("status",ScalarType.pvInt).
         add("message",ScalarType.pvString).
    endNested().
    addNestedStructure("timeStamp").
         add("secondsPastEpoch", ScalarType.pvLong).
         add("nanoseconds",ScalarType.pvInt).
         add("userTag",ScalarType.pvInt).
    endNested().
    createStructure();
System.out.println(structure);
</pre>
This produces the same output as valueAlarmTimeStamp.
   </dd>


   <dt>union</dt>
    <dd>
<pre>
System.out.println("union");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Union union =
    fb.add("short", ScalarType.pvShort).
    add("long", ScalarType.pvLong).
    createUnion();
Structure structure = 
    fb.add("value",union).
    createStructure();
System.out.println(structure);
</pre>
This produces:
<pre>
union
structure
    union value
        short short
        long long`
</pre>
    </dd>
   <dt>unionNested</dt>
   <dd>
<pre>
System.out.println("unionNested");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
    fb.addNestedUnion("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
        endNested().
    createStructure();
System.out.println(structure);
</pre>
This produces the same result as union.
   </dd>

   <dt>unionArray</dt>
   <dd>
<pre>
System.out.println("unionArray");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Union union =
    fb.add("short", ScalarType.pvShort).
    add("long", ScalarType.pvLong).
    createUnion();
Structure structure = 
    fb.addArray("value",union).
    createStructure();
System.out.println(structure);
</pre>
This produces:
<pre>
unionArray
structure
    union[] value
        union
            short short
            long long
</pre>
    </dd>

   <dt>unionArrayNested</dt>
   <dd>
<pre>
System.out.println("unionArrayNested");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
    fb.addNestedUnionArray("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
    endNested().
    createStructure();
System.out.println(structure);
</pre>
This produces the same result as unionArray.
   </dd>

   <dt>structureArray</dt>
   <dd>
<pre>
System.out.println("structureArray");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure subStruct =
    fb.add("short", ScalarType.pvShort).
    add("long", ScalarType.pvLong).
    createStructure();
Structure structure = 
    fb.addArray("value",subStruct).
    createStructure();
System.out.println(structure);
</pre>
This produces:
<pre>
structureArray
structure
    structure[] value
        structure
            short short
            long long
</pre>
   </dd>

   <dt>structureArrayNested</dt>
   <dd>
<pre>
System.out.println("structureArrayNested");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
   fb.addNestedStructureArray("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
    endNested().
    createStructure();
System.out.println(structure);`
</pre>
This produces the same result as structureArray.
   </dd>

</dl>

<h3>Java Data Examples</h3>
<dl>
   <dt>simpleExample</dt>
    <dd>
<pre>
System.out.println("simple");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
    fb.add("value", ScalarType.pvDouble).
    createStructure();
PVStructure pvStructure = pvDataCreate.createPVStructure(structure);
PVDouble pvDouble = pvStructure.getSubField(PVDouble.class, "value");
pvDouble.put(10.0);
System.out.println(pvStructure);
</pre>
    This produces:
<pre>
simple
structure 
    double value 10.0
</pre>
    </dd>
   <dt>valueAlarmTimeStamp</dt>
   <dd>
<pre>
System.out.println("valueAlarmTimeStamp");
FieldBuilder fb = fieldCreate.createFieldBuilder();
StandardField standardField = StandardFieldFactory.getStandardField();
Structure structure =
        fb.addArray("value", ScalarType.pvDouble).
        add("alarm",standardField.alarm()).
        add("timeStamp",standardField.timeStamp()).
        createStructure();
PVStructure pvStructure = pvDataCreate.createPVStructure(structure);
PVDoubleArray pvDoubleArray = pvStructure.getSubField(PVDoubleArray.class, "value");
int length = 4;
double[] data = new double[length];
for (int i=0; &lt;length; ++i) data[i] = i+1;
convert.fromDoubleArray(pvDoubleArray, 0, length, data, 0);
System.out.println(pvStructure);
</pre>
This produces:
<pre>
valueAlarmTimeStamp
structure 
    double[] value [1.0,2.0,3.0,4.0]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0
</pre>
   </dd>

   <dt>union</dt>
   <dd>
<pre>
System.out.println("union");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
    fb.addNestedUnion("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
        endNested().
    createStructure();
PVStructure pvStructure = pvDataCreate.createPVStructure(structure);
PVUnion pvUnion = pvStructure.getSubField(PVUnion.class,"value");
PVLong pvLong = (PVLong)pvDataCreate.createPVScalar(ScalarType.pvLong);
pvLong.put(1000);
pvUnion.set("long",pvLong);
System.out.println(pvStructure);
</pre>
This produces:
<pre>
union
structure 
    union value
        long  1000
</pre>
    </dd>

   <dt>unionArray</dt>
    <dd>
<pre>
System.out.println("unionArray");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
    fb.addNestedUnionArray("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
    endNested().
    createStructure();
PVStructure pvStructure = pvDataCreate.createPVStructure(structure);
PVUnionArray pvValue = pvStructure.getSubField(PVUnionArray.class,"value");
int len = 2;
PVUnion[] pvUnions = new PVUnion[len];
for(int i=0; &lt;len; ++i) pvUnions[i] = pvDataCreate.createPVUnion(pvValue.getUnionArray().getUnion());
pvUnions[0].select("short");
pvUnions[1].select("long");
PVShort pvShort = pvUnions[0].get(PVShort.class);
pvShort.put((short)1);
PVLong pvLong = pvUnions[1].get(PVLong.class);
pvLong.put(5);
pvValue.put(0, len, pvUnions, 0);
System.out.println(pvStructure);
</pre>
This produces:
<pre>
unionArray
structure 
    union[] value 
        union 
            short  1
        union 
            long  5
</pre>
    </dd>

   <dt>structureArray</dt>
   <dd>
<pre>
System.out.println("structureArray");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
        fb.addNestedStructureArray("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
    endNested().
    createStructure();
PVStructure pvStructure = pvDataCreate.createPVStructure(structure);
PVStructureArray pvValue = pvStructure.getSubField(PVStructureArray.class,"value");
int len = 2;
PVStructure[] pvStructures = new PVStructure[len];
for(int i=0; i&lt;len; ++i) {
    pvStructures[i] = pvDataCreate.createPVStructure(pvValue.getStructureArray().getStructure());
    PVStructure pvs = pvStructures[i];
    PVShort pvShort = pvs.getSubField(PVShort.class,"short");
    pvShort.put((short)i);
    PVLong pvLong = pvs.getSubField(PVLong.class,"long");
    pvLong.put(i);
}
pvValue.put(0, len,pvStructures , 0);
System.out.println(pvStructure);
</pre>
This produces:
<pre>
structureArray
structure 
    structure[] value 
        structure 
            short short 0
            long long 0
        structure 
            short short 1
            long long 1
</pre>
   </dd>

   <dt>structureArray</dt>
   <dd>
<pre>
System.out.println("structureArray");
FieldBuilder fb = fieldCreate.createFieldBuilder();
Structure structure = 
   fb.addNestedStructureArray("value").
        add("short", ScalarType.pvShort).
        add("long", ScalarType.pvLong).
    endNested().
    createStructure();
System.out.println(structure);`
</pre>
This produces the same result as structureArray.
   </dd>

</dl>

<h2>API: normativeType</h2>

<p><b>normativeTypes</b> defines a set of standard structures.
Each normative type consists of a set of mandatory fields, a set of optional fields,
and an arbitrary number of extra fields.
The mandatory and optional fields are meant for use by standard tools such
as Display Managers and Alarm Handlers.
The extra fields are for specialized tools.
</p>

<p>normativeTypes provides a set of helper classes for implementing
and using normative types.
For the complete set of normative types see normativeTypesJava or normativeTypesCPP.
</p>
<p>
Some of the types it supports are:</p>
<dl>
  <dt>NTScalar</dt>
     <dd>This has a value field that has type scalar</dd>
  <dt>NTScalarArray</dt>
     <dd>This has a value field that has type scalarArray</dd>
  <dt>NTNameValue</dt>
      <dd>This has a field name that is a string array
       and a field value that has type scalarArray.
       Each name[i] is associated with value[i].
      </dd>
  <dt>NTTable</dt>
      <dd>This has a string array field named labels
       For each label there is a scalar array field with name = label.
     </dd>
  <dt>NTMultiChannel</dt>
     <dd>This has a value field that is a union array.
      A primary use of this type is to access data from a set of pvAccess channels.
      Each element of value holds data from a channel.</dd>
  <dt>NTNDArray</dt>
     <dd>This type holds NDArray data as defined by the areaDetector facility.
     </dd>
</dl>
<p>For example <b>NTScalar</b> is defined as :</p>
<pre>
epics:nt/NTScalar:1.0
    double value                        // mandatory and can be any numeric type
    string descriptor                   // optional
    alarm_t alarm                       // optional
        int severity
        int status
        string message
    time_t timeStamp                    // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    display_t display                   // optional
        double limitLow
        double limitHigh
        string description
        string format
        string units
    control_t control                   // optional
        double limitLow
        double limitHigh
        double minStep
    string extra1                       // extra
    string[] extra2                     //
</pre>

<h2>API: pvaClient</h2>

<p>The following sections use psuedo code to describe methods.
Consult the Java or C++ documentation for the exact syntax.
</p>
<h3>PvaClient Overview</h3>
<p>The pvAccess Client API is:</p>
<ul>
   <li>
       Callback based, i. e. the client must provided code to handle callbacks
      from the server side of pvAccess.
       PvaClient provides a synchronous interface for a client.
   </li>
   <li>Uses Status to show the result of client requests.
       PvaClient throws an exception for a failure status,
       but also provides some methods that allow the client to handle a failure via status.
   </li>
</ul>
<p>PvaClient is a synchronous API for accessing PVData via PVAccess.
It also provides a number of convenience methods.
It allows the client to request access without checking for failure,
but throws an exception when a reuest fails.
A client can also check for failues and thus prevent failures.</p>

<p>The PvaClient API has the following features:</p>
<ol>
  <li>Provides a synchronous API rather than the callback API provided by pvAccess.</li>
  <li>Makes common requests easy.</li>
  <li>Provides full access to the pvAccess API for more demanding
  applications</li>
  <li>Allows efficient client side programs.</li>
  <li>Can cache channels, channelGets, and channelPuts.</li>
  <li>Takes care of most object resource management problems.</li>
</ol>
<p>Simple examples of using pvaClient:</p>
<p>This is a C++ example.</p>
<pre>
// easyGet
PvaClientPtr pvaClient = PvaClient::create();
double value = pvaClient->channel("exampleDouble")->get()->getData()->getDouble();

// easyPut
PvaClientChannelPtr channel = pvaClient->channel("exampleDouble");
PvaClientPutPtr put = channel->put();
PvaClientPutDataPtr putData = put->getData();
putData->putDouble(3.0); put->put();

// easyMonitor
PvaClientMonitorPtr monitor = pvaClient->channel("examplePowerSupply")->monitor("");
PvaClientMonitorDataPtr easyData = monitor->getData();
while(true) {
    monitor->waitEvent();
    cout &lt;&lt; "changed\n";
    easyData->showChanged(cout);
    cout &lt;&lt; "overrun\n";
    easyData->showOverrun(cout);
    monitor->releaseEvent();
}
// easyProcess
PvaClientChannelPtr channel = pvaClient->channel("exampleDouble");
PvaClientProcessPtr process = channel->createProcess();
process->process();
</pre>


<p>PvaClient can cache channels, channelGets, and channelPuts.</p>
<p>A simple Java example is:</p>
<pre>
String channelName = "someChannel";
double value =  pva.channel(channelName).get().getData().getDouble();
...
value = pva.channel(channelName).get().getData().getDouble();
...
</pre>
<p>
The simple example allows the client to get a value from the server with a single call.
This example results in a channel and channelGet both being cached.
The first call results in connecting to the server,
creating a channelGet, and issuing a get request.
The second call reuses the channel and channelGet that were cached by the first request.
If any part of the request fails an exception occurs.
</p>
<p>The same request could also be done by:</p>
<pre>
String channelName = "someChannel";
PvaClientChannel pvaChannel = pva.createChannel(channelName);
pvaChannel.issueConnect();
Status status = pvaChannel.waitConnect(2.0);
if(!status.isOK()) {System.out.println(" connect failed"); return;}
PvaClientGet pvaGet = pvaChannel.createGet();
pvaGet.issueConnect();
status = pvaGet.waitConnect();
if(!status.isOK()) {System.out.println(" createGet failed"); return;}
PvaClientGetData pvaData = pvaGet.getData();
value = pvaData.getDouble();
...
pvaData = pvaGet.getData();
value = pvaData.getDouble();
</pre>
<p>In this case no caching occurs but the client is responsible for lots more then in the simple
example.
</p>
<h3>Class PvaClient</h3>
<pre>
class PvaClient
{
    // methods for creating and accessing the singleton instance of PvaClient
    static PvaClient get(string providerNames = "pva ca");
    // method for creating cached instances of PvaClientChannel
    PvaClientChannel channel(
        string channelName,
        string providerName = "pva",
        double timeOut = 5.0);
    // method for creating non-cached instances of PvaClientChannel
    PvaClientChannel createChannel(
        string channelName,
        string providerName = "pva");
    // methods for ChannelRequester and Requester
    string getRequesterName();
    void message(string message, MessageType type);
    void setRequester(Requester requester);
    void clearRequester();
    // methods for channel cache
    void showCache();
    size_t cacheSize();
    // debug methods
    void setDebug(boolean value);
    boolean getDebug();
    // destroy the singleton instance of PvaClient
    void destroy(); // JAVA Only
}
</pre>
<dl>
    <dt>get</dt>
       <dd>
    <p>For both Java and C++ PvaClient is a singleton class, i. e. there is a single instance created.
    In Java it is created via:</p>
<pre>
PvaClient pva= PvaClient.get("providerList");
</pre>
    An example is:
<pre>
PvaClient pva= PvaClient.get("pva ca");
</pre>
    <p>
    In C++ it is created via:
    </p>
<pre>
PvaClientPtr pva= PvaClient::get("providerList");
</pre>
    An example is:
<pre>
PvaClientPtr pva= PvaClient::get("pva ca");
</pre>
    <p>For both Java and C++ if no argument is specified for get than the default is <b>"pva ca"</b>
    </p>
    <p>If get is called multiple times only the first call creates the single instance
    of PvaClient. Additional calls return the same instance.</p> 
    <p>Two providers are special:</p>
    <dl>
      <dt>pva</dt>
         <dd>The client side of provider <b>pva</b>
           is registered and started.</dd>
      <dt>ca</dt>
         <dd>The client side of provider <b>ca</b> is registered and started.
           V3 implements the server side of the <b>ca</b> network protocal.
         </dd>
    </dl>
    <p>Other client providers can be specicified but must be registered and started before
    PvaClient is started.</p>
    <p>PvaClient provides a cache for channels, channelGet, etc.
    Thus in the following:</p>
<pre>
PvaClient pva= PvaClient.get();
...
double value = pva.channel(channelName).get().getData().getDouble();
...
value = pva.channel(channelName).get().getData().getDouble();
</pre>
    <p>Only the first call for value will result in connection to channelName and creation of
    a ChannelGet.
    The second call uses a cached channel and a cached channelGet.
    The next section describes when instances are cached.
    </p>
    <p>
    All cached objects and context for providers <b>pva</b> and <b>ca</b> are destroyed when
    the destructor for PvaClient is called.
    For Java the client must call <b>pva.destroy()</b>.
    For C++ this is done automatically when the destructor for PvaClient is called.
    </p>
    </dd>

   <dt>channel</dt>
   <dd>
    This method creates and connects to cached channels.<br />
    If a channel for <b>channelName</b> and <b>providerName</b> already exists in the cache
    it is just returned.
    <br />
    If it is not found in the cache
    Then an attempt is made to connect to the channel.
    If the attempt fails an exception is thrown.<br />
    If the attempt succeeds the channel is cached and returned to the caller.
    <br />
    </dd>

    <dt>createChannel</dt>
    <dd>
    A channel is created and returned to the caller,
    but the channel is not connected to the server.
     <br />
    The caller must call PvaClientChannel methods to connect.
     <br />
    The channel is not cached.
    <br />
    </dd>
    <dt>Requester Methods</dt>
    <dd>
    PvaClient implements interfaces ChannelRequester and Requester,
     which are required by pvAccess, but also allows the user to implement Requester.
    </dd>
    <dt>Cache Methods</dt>
    <dd>These are methods for seeing what is in the cache.</dd>
    <dt>PvaClient:: Debug Merhods</dt>
    <dd>This is a way to get debug output while using PvaClient.
    These are static methods that can be used by all the classes that are part of PvaClient.
    They can also be used by client code.
    </dd>
</dl>

<h3>Class PvaClientChannel</h3>

<pre>
class PvaClientChannel
{
    // connect and throw if failure
    void connect(double timeOut = 5.0);
    // connect and return Status if failure
    void issueConnect();
    Status waitConnect(double timeOut = 5.0);
    // Create a PvaClientField   NOT IMPLEMENTED
    PvaClientField createField(string subField = "");
    // create a PvaClientProcess
    PvaClientProcess createProcess(string  request = "");
    PvaClientProcess createProcess(PVStructure   pvRequest);
    // create a cached PvaClientGet
    PvaClientGet get(string  request = "value,alarm,timeStamp");
    // create a non cached PvaClientGet
    PvaClientGet createGet(string  request  = "value,alarm,timeStamp");
    PvaClientGet createGet(PVStructure   pvRequest);
    // create a cached PvaClientPut
    PvaClientPut put(string  request = "value");
    // create a non cached PvaClientPut
    PvaClientPut createPut(std::string  request = "value");
    PvaClientPut createPut(PVStructure  pvRequest);
    // create a PvaClientPutGet
    PvaClientPutGet createPutGet(string  request ="putField(argument)getField(result)" );
    PvaClientPutGet createPutGet(PVStructure  pvRequest);
    // create, connect, and start PvaClientMonitor
    PvaClientMonitor monitor(string  request = "value,alarm,timeStamp");
    PvaClientMonitor monitor(PvaClientMonitorRequester  pvaClientMonitorRequester);
    PvaClientMonitor monitor(string  request,PvaClientMonitorRequester pvaClientMonitorRequester);
    // create PvaClientMonitor. client must call PvaClientMonitor methods to create and start.
    PvaClientMonitor createMonitor(request = "value,alarm,timeStamp");
    PvaClientMonitor createMonitor(PVStructure   pvRequest);
    // create a PvaClientArray NOT IMPLEMENTED
    PvaClientArray createArray(string request = "");
    // create a PvaClientArray NOT IMPLEMENTED
    PvaClientArray createArray(PVStructure pvRequest);
    void setStateChangeRequester(PvaClientChannelStateChangeRequester stateChangeRequester);
    oid clearRequester();
    // methods for get and put cache
    void showCache();
    size_t cacheSize();
    // misc methods
    string getChannelName();
    Channel getChannel();
    void destroy(); // Java only

}
</pre>
<dl>
   <dt>connect</dt>
     <dd>
      This calls issueConnect and waitConnect.
      An exception is thrown if the connection request fails.
     </dd>
   <dt>issueConnect</dt>
     <dd>
      A connection request is issued and the method returns to the caller who must
      call waitConnect. Note that the caller can issue multiple issueConnect calls, for different PvaChannels, before
      calling waitConnect for each issueConnect.
      Thus the issueConnect calls are making parallel requests to connect to the servers.
     </dd>
     <dt>waitConnect</dt>
     <dd>
       Wait for the issueConnect request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
     </dd>
     <dt>createField</dt>
       <dd>NOT IMPLEMENTED</dd>
     <dt>createProcess</dt>
     <dd>
      If the channel is not connected call connect.<br />
      A PvaClientProcess is created.<br />
      The client must call the PvaClientProcess to connect and issue process requests.
     </dd>
     <dt>get</dt>
     <dd>
      See if a get for the same request is cached.
      If so it is returned.
      <br />
      If none is cached, create and connect to a PvaClientGet, cache it, and returns it to the client.
      <br />
      If any part of the request fails an exception is thrown. 
     </dd>
     <dt>createGet</dt>
      <dd>
      If the channel is not connected call connect.
      <br />
      A PvaClientGet is created.
      <br />
      The client must call the PvaClientGet methods to connect and issue put requests.
      <br />
       The channelGet is not cached.
     </dd>
     <dt>put</dt>
     <dd>
      See if a put for the same request is cached.
      If so it is returned.
      <br />
      If none is cached it creates and connects a PvaClientPut, caches it, and returns it to the client.
      <br />
      If any part of the request fails an exception is thrown. 
     </dd>
     <dt>createPut</dt>
      <dd>
      If the channel is not connected call connect.<br />
      A PvaClientPut is created.
      <br />
      The client must call the PvaClientPut methods to connect and issue put requests.
      <br />
       The channelPut is not cached.
     </dd>
     <dt>createPutGet</dt>
      <dd>
      If the channel is not connected call connect.
      <br />
      A PvaClientPutGet is created.
      <br />
      The client must call the PvaClientPutGet methods to connect and issue put requests.
     </dd>
     <dt>monitor</dt>
     <dd>
      Create and connect to a new PvaClientMonitor.
      <br />
      Then call the start method.
      <br />
      If any part of the request fails an exception is thrown.
      <br />
      If the caller provides argument PvaClientMonitorRequester,
      then the caller will be notified when new events are available.
      Otherwise the caller must call poll and/or waitEvent. 
     </dd>
     <dt>createMonitor</dt>
      <dd>
      If the channel is not connected call connect.<br />
      A PvaClientMonitor is created.
      <br />
      The client must call the PvaClientMonitor methods to connect and start.
      </dd>
     <dt>createArray</dt>
     <dd>
     NOT IMPLEMENTED.
     </dd>
     <dt>setStateChangeRequester</dt>
        <dd>Set a user callback for channel change of state.</dd>
     <dt>clearRequester</dt>
        <dd>Clear the user callback</dd>
     <dt>getChannelName</dt>
        <dd>Get the channel name.</dd>
     <dt>getChannel</dt>
        <dd>get the pvAccess channel interface.<br />
          This can be used if the client needs access to methods not provided by pvaClient.
        </dd>
     <dt>destroy</dt>
        <dd>Java only. C++ implemnts RAII.<br />
          Disconnect the channel and destroy the channel context.
        </dd>
</dl>
<h4>PvaClientMonitorRequester</h4>
<p>
The following is a class that a client can implement it it wants to be notified when the sever sends
new monitors to the client.
The client can also handle monitors by polling.
See PvaClientMonitor below for details.
</p>
<pre>
class PvaClientMonitorRequester
{
    void event(PvaCientMonitor monitor);
}
</pre>
where
<dl>
   <dt>event</dt>
   <dd>One or more new events are available.</dd>
</dl>

<h4>PvaClientChannelStateChangeRequester</h4>
<p>
The following is a class that a client can implement it it wants to be notified when a change of
state for a channel occurs.
</p>
<pre>
class PvaClientChannelStateChangeRequester 
{
    void channelStateChange(PvaClientChannel channel, boolean isConnected);
}
</pre>
where
<dl>
   <dt>channelStateChange</dt>
   <dd>A change in state for the channel has occured,</dd>
</dl>
<h3>Class PvaClientGet</h3>
<pre>
class PvaClientGet
{
    void connect();
    void issueConnect();
    Status waitConnect();
    void get();
    void issueGet();
    Status waitGet();
    PvaClientGetData getData();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
    This calls issueConnect and waitConnect.
    An exception is thrown if the connection request fails.
    </dd>
    <dt>issueConnect</dt>
     <dd>
       A connection request is issued and the method returns to the caller who must
      call waitConnect.
      <br />
      The caller can issue multiple issueConnect calls, 
       for different PvaChannelGets,
      before calling waitConnect for each issueConnect.
      Thus the issueConnect calls are making parallel requests to connect to the servers.
    </dd>
    <dt>waitConnect</dt>
    <dd>
       Wait for the issueConnect request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>get</dt>
    <dd>
      This calls issueGet and waitGet.
      An exception is thrown if any error arises.
    </dd>
    <dt>issueGet</dt>
    <dd>
      <p>
      If the channel is not connected then a connect request is issued.
      If the connect request fails an exception is thrown.
      </p>
      <p>
      A get request is issued and the method returns to the caller who must
      call waitGet. Note that the caller can issue multiple issueGet calls before
      calling waitGet for each issueGet.
      Thus the issueGet calls are making parallel requests to the servers.
      </p>
    </dd>
    <dt>waitGet</dt>
    <dd>
       Wait for the issueGet request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>getData</dt>
    <dd>
       Get the data for the previous get.
       This must be called after each successful get.
    </dd>
</dl>
<p>The following is for the data</p>
<pre>
class PvaClientGetData
{
    Structure getStructure();
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    showChanged() // different syntax for Java and C++
    void setData(PVStructure pvStructure, BitSet bitSetFrom);
    bool hasValue();
    bool isValueScalar();
    bool isValueScalarArray();
    PVField getValue();
    PVScalar getScalarValue();
    PVArray[] getArrayValue();
    PVScalarArray getScalarArrayValue();
    double getDouble();
    string getString();
    double[] getDoubleArray();
    string[] getStringArray();
    Alarm getAlarm();
    TimeStamp getTimeStamp();
}
</pre>
where
<dl>
    <dt>getStructure</dt>
    <dd>
     Get the introspection interface for the data.
    </dd>
    <dt>getPVStructure</dt>
    <dd>
       Get all the data.
    </dd>
    <dt>getChangedBitSet</dt>
    <dd>
       Get the changed bit set for PVStructure,
    </dd>
    <dt>showChanged</dt>
    <dd>
       Show all fields that have changed value since the previous get.
    </dd>
    <dt>setData</dt>
    <dd>
       Set data into PVStructure.<br />
       This is <b>not</b> normally called by the client but by the implementation.
    </dd>
    <dt>hasValue</dt>
    <dd>
      Does the Structure have a top level field named <b>value</b>?
    </dd>
    <dt>isValueScalar</dt>
    <dd>
      Is the <b>value</b> field a scalar?
    </dd>
    <dt>isValueScalarArray</dt>
    <dd>
      Is the <b>value</b> field a scalar array?
    </dd>
    <dt>getValue</dt>
    <dd>
      Get the value field as a PVField.<br />
      The caller can use introspection to find the actual type.<br />
      An exception is thrown if a top level field named <b>value</b> does not exist.
    </dd>
    <dt>getScalarValue</dt>
    <dd>
       Get the <b>value</b> field as a scalar.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getArrayValue</dt>
    <dd>
      Get the <b>value</b> field as an array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getScalarArrayValue</dt>
    <dd>
       Get the <b>value</b> field as a scalar array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getDouble</dt>
    <dd>
       Get the <b>value</b> field as a double.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getString</dt>
    <dd>
      Get the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getDoubleArray</dt>
    <dd>
      Get the <b>value</b> field as a double array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getStringArray</dt>
    <dd>
      Get the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getAlarm</dt>
    <dd>
      Get the data for a top level alarm field.<br />
      An exception is thrown if the request is not valid.
    </dd>
    <dt>getTimeStamp</dt>
    <dd>
       Get the data for a top level timeStamp field.<br />
      An exception is thrown if the request is not valid.
    </dd>
</dl>
<h3>Class PvaClientPut</h3>
<pre>
class PvaClientPut
{
    void connect();
    void issueConnect();
    Status waitConnect();
    void get();
    void issueGet();
    Status waitGet();
    void put();
    void issuePut();
    Status waitPut();
    PvaClientPutData getData();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
    This calls issueConnect and waitConnect.
    An exception is thrown if the connection request fails.
    </dd>
    <dt>issueConnect</dt>
    <dd>
       A connection request is issued and the method returns to the caller who must
      call waitConnect.
      <br />
       The caller can issue multiple issueConnect calls, 
       for different PvaChannelPuts, before
      calling waitConnect for each issueConnect.
      Thus the issueConnect calls are making parallel requests to connect to the servers.
    </dd>
    <dt>waitConnect</dt>
    <dd>
       Wait for the issueConnect request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>get</dt>
    <dd>
      Get the curent value stored in the server.
      This calls issueGet and waitGet.
      An exception is thrown if any error arises.
    </dd>
    <dt>issueGet</dt>
    <dd>
      A get request is issued and the method returns to the caller who must
      call waitGet.
      <br />
      The caller can issue multiple issueGet calls before
      calling waitGet for each issueGet.
      Thus the issueGet calls are making parallel requests to the servers.
    </dd>
    <dt>waitGet</dt>
    <dd>
       Wait for the issueGet request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>put</dt>
    <dd>
      Put data to the server.
      All fields in PvaClientPutData that have a changed BitSet are sent to the server. 
      This calls issuePut and waitPut.
      An exception is thrown if any error arises.
    </dd>
    <dt>issuePut</dt>
    <dd>
      A put request is issued and the method returns to the caller who must
      call waitPut.
      <br />
      The caller can issue multiple issuePut calls before
      calling waitPut for each issuePut.
      Thus the issuePut calls are making parallel requests to the servers.
    </dd>
    <dt>waitPut</dt>
    <dd>
       Wait for the issuePut request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>getData</dt>
    <dd>
      Get the PvaClientPutData.
      This only needs to be called before the first put.
      The BitSet is cleared automatically after each successful put.
      If get is issued then the BitSet shows the changes since the last get.
      In this case the BitSet should be cleared before the next put.
    </dd>
</dl>
<pre>
class PvaClientPutData
{
    Structure getStructure();
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    showChanged() // different syntax for Java and C++
    bool hasValue();
    bool isValueScalar();
    bool isValueScalarArray();
    PVField getValue();
    PVScalar getScalarValue();
    PVArray[] getArrayValue();
    PVScalarArray getScalarArrayValue();
    double getDouble();
    string getString();
    double[] getDoubleArray();
    string[] getStringArray();
    void putDouble(double value);
    void putString(string value);
    void putDoubleArray(double[] value);
    void putStringArray(string[] value);
}
</pre>
where
<dl>
    <dt>getStructure</dt>
    <dd>
     Get the introspection interface for the data.
    </dd>
    <dt>getPVStructure</dt>
    <dd>
       Get all the data.
    </dd>
    <dt>getChangedBitSet</dt>
    <dd>
       Get the changed bit set for PVStructure,
    </dd>
    <dt>showChanged</dt>
    <dd>
       Show all fields that have changed value since the previous get or put.
    </dd>
    <dt>hasValue</dt>
    <dd>
      Does the Structure have a top level field named <b>value</b>?
    </dd>
    <dt>isValueScalar</dt>
    <dd>
      Is the <b>value</b> field a scalar?
    </dd>
    <dt>isValueScalarArray</dt>
    <dd>
      Is the <b>value</b> field a scalar array?
    </dd>
    <dt>getValue</dt>
    <dd>
      Get the value field as a PVField.<br />
      The caller can use introspection to find the actual type.<br />
      An exception is thrown if a top level field named <b>value</b> does not exist.
    </dd>
    <dt>getScalarValue</dt>
    <dd>
       Get the <b>value</b> field as a scalar.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getArrayValue</dt>
    <dd>
      Get the <b>value</b> field as an array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getScalarArrayValue</dt>
    <dd>
       Get the <b>value</b> field as a scalar array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getDouble</dt>
    <dd>
       Get the <b>value</b> field as a double.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getString</dt>
    <dd>
      Get the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getDoubleArray</dt>
    <dd>
      Get the <b>value</b> field as a double array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getStringArray</dt>
    <dd>
      Get the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>putDouble</dt>
    <dd>
       Get the <b>value</b> field as a double.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>putString</dt>
    <dd>
      Put the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>putDoubleArray</dt>
    <dd>
      Put the <b>value</b> field as a double array.<br />
       An exception is thrown if the request is not valid.
    </dd>
   <dt>putStringArray</dt>
    <dd>
      Put the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
</dl>
<h3>Class PvaClientPutGet</h3>
<pre>
class PvaClientPutGet
{
    void connect();
    void issueConnect();
    Status waitConnect();
    void putGet();
    void issuePutGet();
    Status waitPutGet();
    void getGet();
    void issueGetPut();
    Status waitGetPut();
    void getGet();
    void issueGetGet();
    Status waitGetGet();
    void getPut();
    void issueGetPut();
    Status waitGetPut();
    PvaClientPutData getPutData();
    PvaClientGetData getGetData(); 
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
    This calls issueConnect and waitConnect.
    An exception is thrown if the connection request fails.
    </dd>
    <dt>issueConnect</dt>
    <dd>
       A connection request is issued and the method returns to the caller who must
      call waitConnect.
      <br />
      The caller can issue multiple issueConnect calls,
      for different PvaChannelPutGets, before
      calling waitConnect for each issueConnect.
      Thus the issueConnect calls are making parallel requests to connect to the servers.
    </dd>
    <dt>waitConnect</dt>
    <dd>
       Wait for the issueConnect request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>putGet</dt>
    <dd>
      All fields in PvaClientPutData that have a changed BitSet are sent to the server,
      the server normally issues a process request, and the data received from the server
      is put into PvaClientGetData.
      This calls issuePutGet and waitPutGet.
      An exception is thrown if any error arises.
    </dd>
    <dt>issuePutGet</dt>
    <dd>
      A putGet request is issued and the method returns to the caller who must
      call waitPutGet.
      <br />
      The caller can issue multiple issuePutGet calls before
      calling waitPutGet for each issuePutGet.
      Thus the issuePutGet calls are making parallel requests to the servers.
    </dd>
    <dt>waitPutGet</dt>
    <dd>
       Wait for the issuePutGet request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>getGet</dt>
    <dd>
      Get the curent PvaClientGetData is retrieved from the server.
      This calls issueGetGet and waitGetGet.
      An exception is thrown if any error arises.
    </dd>
    <dt>issueGetGet</dt>
    <dd>
      A getGet request is issued and the method returns to the caller who must
      call waitGetGet.
      <br />
      The caller can issue multiple issueGetGet calls before
      calling waitGetGet for each issueGetGet.
      Thus the issueGetGet calls are making parallel requests to the servers.
    </dd>
    <dt>waitGetGet</dt>
    <dd>
       Wait for the issueGetGet request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>getPut</dt>
    <dd>
      Get the curent PvaClientPutData is retrieved from the server.
      This calls issueGetPut and waitGetPut.
      An exception is thrown if any error arises.
    </dd>
    <dt>issueGetPut</dt>
    <dd>
      A getPut request is issued and the method returns to the caller who must
      call waitGetPut.
      <br />
      The caller can issue multiple issueGetPut calls before
      calling waitGetPut for each issueGetPut.
      Thus the issueGetPut calls are making parallel requests to the servers.
    </dd>
    <dt>waitGetPut</dt>
    <dd>
       Wait for the issueGetPut request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>   
    <dt>getPutData</dt>
    <dd>
      Get the PvaClientPutData.
      This only needs to be called before the first putGet.
      The BitSet is cleared automatically after each successful putGet.
      If getPut is issued then the BitSet shows the changes since the last getPut.
      In this case the BitSet should be cleared before the next putGet.
    </dd>
    <dt>getGetData</dt>
    <dd>
      Get the PvaClientGetData.
      This must be called after each successfull putGet and getGet.
    </dd>
</dl>
<h3>Class PvaClientProcess</h3>
<pre>
class PvaClientProcess
{
    void connect();
    void issueConnect();
    Status waitConnect();
    void process();
    void issueProcess();
    Status waitProcessx();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
    This calls issueConnect and waitConnect.
    An exception is thrown if the connection request fails.
    </dd>
    <dt>issueConnect</dt>
    <dd>
       A connection request is issued and the method returns to the caller who must
      call waitConnect.
      <br />
      The caller can issue multiple issueConnect calls,
      for different PvaChannelProcesss, before
      calling waitConnect for each issueConnect.
      Thus the issueConnect calls are making parallel requests to connect to the servers.
    </dd>
    <dt>waitConnect</dt>
    <dd>
       Wait for the issueConnect request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>process</dt>
    <dd>
    This calls issueProcess and waitProcess.
    An exception is thrown if the request fails.
    </dd>
    <dt>issueProcess</dt>
    <dd>
       A process request is issued and the method returns to the caller who must
      call waitProcess.
      <br />
      The caller can issue multiple issueProcess calls before
      calling waitProcess for each issueProcess.
      Thus the issueProcess calls are making parallel requests to the servers.
    </dd>
    <dt>waitProcess</dt>
     <dd>
       Wait for the issueProcess request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
</dl>
<h3>Class PvaClientMonitor</h3>
<pre>
class PvaClientMonitor
{
    void connect();
    void issueConnect();
    Status waitConnect();
    void setRequester(PvaClientMonitorRequesterpvaClientMonitorrRequester);
    void start();
    void stop();
    bool poll();
    bool waitEvent(double secondsToWait = 0.0);
    void releaseEvent();
    PvaClientMonitorData getData(); 
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
    This calls issueConnect and waitConnect.
    An exception is thrown if the connection request fails.
    </dd>
    <dt>issueConnect</dt>
    <dd>
       A connection request is issued and the method returns to the caller who must
      call waitConnect.
      <br />
      The caller can issue multiple issueConnect calls,
      for different PvaChannelMonitors, before
      calling waitConnect for each issueConnect.
      Thus the issueConnect calls are making parallel requests to connect to the servers.
    </dd>
    <dt>waitConnect</dt>
    <dd>
       Wait for the issueConnect request to complete.
       Status shows the result of the request.
       If status.isOK() is false then the request failed and status.getMessage() can
         be called to see why the request failed.
    </dd>
    <dt>setRequester</dt>
    <dd>
       Set a client requester to be called when a monitor occurs.
       The argument can be null if the client no longer wants to be called directly.
       <br />
        If the client is directly notified then the client can call poll and releaseEvent.
    </dd>
    <dt>start</dt>
    <dd>
      Start monitoring.
    </dd>
    <dt>stop</dt>
    <dd>
       Stop moitoring.
    </dd>
    <dt>poll</dt>
    <dd>
      Poll for a new monitor event.<br />
      If the return value is <b>true</b> then
      <b>getData</b> is called to get the data and <b>releaseEvent</b> must be called
      when the client is done with the data.
    </dd>
    <dt>waitEvent</dt>
    <dd>
      Wait for an event. A value of 0 means wait forever.
      Is success the <b>poll</b> is called to get the outstanding events.
    </dd>
    <dt>releaseEvent</dt>
    <dd>
      Must be called to release the event.
    </dd>
    <dt>getData</dt>
    <dd>
       Get the data for the last successful poll request.
       This must be called after each successful pull.
    </dd>
</dl>
<pre>
class PvaClientMonitorData
{
    Structure getStructure();
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
    showChanged() // different syntax for Java and C++
    showOverrun() // different syntax for Java and C++
    bool hasValue();
    bool isValueScalar();
    bool isValueScalarArray();
    PVField getValue();
    PVScalar getScalarValue();
    PVArray[] getArrayValue();
    PVScalarArray getScalarArrayValue();
    double getDouble();
    string getString();
    double[] getDoubleArray();
    string[] getStringArray();
    Alarm getAlarm();
    TimeStamp getTimeStamp();
    
}
</pre>
where
<dl>
    <dt>getStructure</dt>
    <dd>
     Get the introspection interface for the data.
    </dd>
    <dt>getPVStructure</dt>
    <dd>
       Get all the data.
    </dd>
    <dt>getChangedBitSet</dt>
    <dd>
       Get the changed bit set for PVStructure,
    </dd>
    <dt>getOverrunBitSet</dt>
    <dd>
       Get the overrun bit set for PVStructure,
    </dd>
    <dt>showChanged</dt>
    <dd>
       Show all fields that have changed value since the previous poll.
    </dd>
    <dt>showOverrun</dt>
    <dd>
       Show all fields that have overrun since the previous poll.
    </dd>
    <dt>hasValue</dt>
    <dd>
      Does the Structure have a top level field named <b>value</b>?
    </dd>
    <dt>isValueScalar</dt>
    <dd>
      Is the <b>value</b> field a scalar?
    </dd>
    <dt>isValueScalarArray</dt>
    <dd>
      Is the <b>value</b> field a scalar array?
    </dd>
    <dt>getValue</dt>
    <dd>
      Get the value field as a PVField.<br />
      The caller can use introspection to find the actual type.<br />
      An exception is thrown if a top level field named <b>value</b> does not exist.
    </dd>
    <dt>getScalarValue</dt>
    <dd>
       Get the <b>value</b> field as a scalar.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getArrayValue</dt>
    <dd>
      Get the <b>value</b> field as an array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getScalarArrayValue</dt>
    <dd>
       Get the <b>value</b> field as a scalar array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getDouble</dt>
    <dd>
       Get the <b>value</b> field as a double.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getString</dt>
    <dd>
      Get the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getDoubleArray</dt>
    <dd>
      Get the <b>value</b> field as a double array.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getStringArray</dt>
    <dd>
      Get the <b>value</b> field as a string.<br />
       An exception is thrown if the request is not valid.
    </dd>
    <dt>getAlarm</dt>
    <dd>
      Get the data for a top level alarm field.<br />
      An exception is thrown if the request is not valid.
    </dd>
    <dt>getTimeStamp</dt>
    <dd>
       Get the data for a top level timeStamp field.<br />
      An exception is thrown if the request is not valid.
    </dd>
</dl>
<h3>Class PvaClientMultiChannel</h3>
<pre>
class PvaClientMultiChannel
{
    static PvaClientMultiChannel create(
        PvaClient pvaClient,
        string[] channelNames,
        string providerName = "pva",
        size maxNotConnected = 0);
    string[] getChannelNames();
    Status connect(double timeout=5.0);
    bool allConnected();
    bool connectionChange();
    bool[] getIsConnected();
    PvaClientChannel[] getPvaClientChannelArray();
    PvaClient getPvaClient();
    PvaClientMultiGetDouble createGet();
    PvaClientMultiPutDouble createPut();
    PvaClientMultiMonitorDoublePtr createMonitor();
    PvaClientNTMultiPut createNTPut();
    PvaClientNTMultiGet createNTGet(string request = "value,alarm,timeStamp");
    PvaClientNTMultiMonitor createNTMonitor(string request = "value,alarm,timeStamp");
}
</pre>
where
<dl>
    <dt>create</dt>
    <dd>
    A static method for creating a new instance of PvaMultiChannel,
    which is a class for connection to a set of channels.
    </dd>
    <dt>getChannelNames</dt>
    <dd>
     Get the channel names.
    </dd>
    <dt>connect</dt>
    <dd>
     Connect to the channels.
     The Status provides the result.
    </dd>
    <dt>allConnected</dt>
    <dd>
     Are all channels connected?
    </dd>
    <dt>connectionChange</dt>
    <dd>
     Is there a change in connection status since the last call?
    </dd>
    <dt>getIsConnected</dt>
    <dd>
      Get the connection state of all the channels.
    </dd>
    <dt>getPvaClientChannelArray</dt>
    <dd>
      Get the array of PvaClientChannel.
    </dd>
    <dt>getPvaClient</dt>
    <dd>
      Get the singleton instance of PvaClient.
    </dd>
    <dt>createGet</dt>
    <dd>
      Create a PvaClientMultiGetDouble for getting each channel as a double.
      This throws an exception if the request is not valid.
    </dd>
    <dt>createPut</dt>
    <dd>
      Create a PvaClientMultiPutDouble for getting each channel as a double.
      This throws an exception if the request is not valid.
    </dd>
    <dt>createMonitor</dt>
    <dd>
      Create a PvaClientMultiMonitorDouble for getting each channel as a double.
      This throws an exception if the request is not valid.
    </dd>
    <dt>createNTPut</dt>
    <dd>
     Creates a PvaClientNTMultiPut.
     This throws an exception if any channel does not have a field named <b>value</b>.
    </dd>
    <dt>createNTGet</dt>
    <dd>
    Creates a PvaClientNTMultiGet.
     This throws an exception if any channel does not have a field named <b>value</b>.
    </dd>
    <dt>createNTMonitor</dt>
    <dd>
     Creates a PvaClientNTMultiMonitor.
     This throws an exception if any channel does not have a field named <b>value</b>.
    </dd>
</dl>
<h3>Class PvaMultiGetDouble</h3>
<pre>
class PvaMultiGetDouble
{
    void connect();
    double[] get();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
     Create a channelGet for each channel.
    </dd>
    <dt>get</dt>
    <dd>
     Issue a get for each channel.
      Return the data as an array of doubles.
    </dd>
</dl>
<h3>Class PvaMultiPutDouble</h3>
<pre>
class PvaMultiPutDouble {
    void connect();
    void put(double[] value);
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
     Create a channelPut for each channel.
    </dd>
    <dt>get</dt>
    <dd>
     Issue a put for each channel.
     Returns when all puts are complete.
    </dd>
</dl>
<h3>Class PvaMultiMonitorDouble</h3>
<pre>
class PvaMultiMonitorDouble
{
    void connect();
    bool poll();
    bool waitEvent(double secondsToWait);
    double[] get();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
     Create a monitor for each channel.
    </dd>
    <dt>poll</dt>
    <dd>
     Poll for new events.
    </dd>
    <dt>waitEvent</dt>
    <dd>
       Wait for events or until timeout.
       It return is <b>true</b> then poll is called to get the data.
    </dd>
    <dt>get</dt>
      <dd>
       Get the data. This call also releases the current event for each channel.
    </dd>
</dl>
<h3>Class PvaClientNTMultiPut</h3>
<pre>
class PvaClientNTMultiPut
{
    void connect();
    PVUnion[] getValues();
    void put();

}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
     Create a channelPut for each channel.
    </dd>
    <dt>getValues</dt>
    <dd>
     Get an array of PVUnion for the value field of each channel.
      The client sets values before making a call to <b>put</b>. 
    </dd>
    <dt>put</dt>
    <dd>
     Put a value to each channel.
    </dd>
</dl>
<h3>Class PvaClientNTMultiGet</h3>
<pre>
class PvaClientNTMultiGet
{
    void connect();
    void get();
    PvaClientNTMultiData getData();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
     Create a channelGet for each channel.
    </dd>
    <dt>get</dt>
    <dd>
    Issue a get for each channel.<br />
     <b>getData</b> is called to get the data.
    </dd>
    <dt>getData</dt>
    <dd>
     Get the data as an PvaClientNTMultiData.
    </dd>
</dl>
<pre>
class PvaClientNTMultiData
{
    size_t getNumber();
    void startDeltaTime();
    void endDeltaTime();
    TimeStamp getTimeStamp();
    NTMultiChannel getNTMultiChannel();
}
</pre>
<dl>
    <dt>getNumber</dt>
    <dd>
    Get the number of channels.
    </dd>
    <dt>startDeltaTime</dt>
    <dd>
      Set the timeStamp base for computing deltaTimes.
    </dd>
    <dt>endDeltaTime</dt>
    <dd>
      Update NTMultiChannel fields.
    </dd>
    <dt>getTimeStamp</dt>
    <dd>
     Get the time when the last get was made.
    </dd>
    <dt>getNTMultiChannel</dt>
    <dd>
     Get the  NTMultiChannel.
    </dd>
</dl>
<h3>Class PvaClientNTMultiMonitor</h3>
<pre>
class PvaClientNTMultiMonitor
{
    void connect();
    bool poll();
    bool waitEvent(double secondsToWait);
    PvaClientNTMultiData getData();
}
</pre>
where
<dl>
    <dt>connect</dt>
    <dd>
     Create a channel monitor for each channel
    </dd>
    <dt>poll</dt>
    <dd>
     poll each channel.<br />
     If result is true than <b>getData</b> returns the data.
    </dd>
    <dt>waitEvent</dt>
    <dd>
      Wait until poll returns true.<br />
      A thread sleep of .1 seconds occurs between each call to poll.
    </dd>
    <dt>getData</dt>
    <dd>
     Get the data.
    </dd>
</dl>
<pre>
class PvaClientNTMultiData
{
    size getNumber();
    void startDeltaTime();
    void endDeltaTime();
    TimeStamp getTimeStamp(); 
    NTMultiChannel getNTMultiChannel();
}
</pre>
where
<dl>
    <dt>getNumber</dt>
    <dd>
    Get the number of channels.
    </dd>
    <dt>startDeltaTime</dt>
    <dd>
     Set the timeStamp base for computing deltaTimes.
    </dd>
    <dt>endDeltaTime</dt>
    <dd>
      Update NTMultiChannel fields.
    </dd>
    <dt>getTimeStamp</dt>
    <dd>
     Get the time when the last get was made or monitor poll returned true.
    </dd>
    <dt>getNTMultiChannel</dt>
    <dd>
      Get the  NTMultiChannel.
    </dd>
</dl>

<h2>API: pvDatabase</h2>
<h3>pvDatabase Overview</h3>
<p>A brief description of a pvDatabase is that it is a set of network accessible, smart, memory resident records. Each record has data composed of a top level PVStructure. Each record has a name which is the channelName for pvAccess. A local Channel Provider implements the complete ChannelProvider and Channel interfaces as defined by pvAccess. The local provider provides access to the records in the pvDatabase. This local provider is accessed by the remote pvAccess server. A record is smart because code can be attached to a record, which is accessed via a method named process.</p>
<p>Implementations for both Java and C++ are available.</p>
<p>
With the C++ implementation (pvDatabaseCPP) the pvDatabase
can be provided via a Main program or can be part of a V3IOC. In the later case the IOC has both a database of V3 Records and PVRecords.
Thus pvDatabase can be used to develop V4 services for V3IOCs.
</p>
<h3>Class PVRecord</h3>
<p>Note that exampleCPP and exampleJava both provide examples for implementing pvRecords.</p>
<h4>Class PVListener</h4>
<pre>
class PVListener // class for local provider
{
    void dataPut(PVRecordField pvRecordField);
    void dataPut(PVRecordStructure requested,PVRecordField pvRecordField); 
    void beginGroupPut(PVRecord pvRecord);
    void endGroupPut(PVRecord pvRecord);
    void unlisten(PVRecord pvRecord);
}
</pre>
<p>where</p>
<dl>
   <dt>dataPut(PVRecordFieldPtr const &amp; pvRecordField)</dt>
     <dd>pvField has been modified.
        This is called if the listener has called PVRecordField::addListener for pvRecordField.</dd>
   <dt>dataPut(
        PVRecordStructurePtr const &amp;
        requested,PVRecordFieldPtr const &amp; pvRecordField)</dt>
     <dd>pvField has been modified.
         Requested is the field to which the requester issued a pvField-&gt;addListener.
         This is called if the listener has called PVRecordField-&gt;addListener for requested.</dd>
   <dt>beginGroupPut</dt>
     <dd>A related set of changes is being started.</dd>
   <dt>endGroupPut</dt>
     <dd>A related set of changes is done.</dd>
   <dt>unlisten</dt>
     <dd>The record is being destroyed. The listener must release all
     access to the record.</dd>
</dl>
<h4>class PVRecordClient</h4>
<pre>
class PVRecordClient // class for local provider
{
   void detach(PVRecord pvRecord)
}
</pre>
<p>where</p>
<dl>
   <dt>detach</dt>
     <dd>The record is being removed from the master database,</dd>
</dl>
<h4>Class PVRecord</h4>
<pre>
class PVRecordField // class for pvCopy
class PVRecordStructure // class for pvCopy

class PVRecord
{
    static PVRecord create(string recordName,PVStructure pvStructure);  // C++ only
    PVRecord(string recordName,PVStructure pvStructure);
    ~PVRecord()          // C++ only
    boolean init();      // C++ only
    void initPVRecord(); // C++ only
    void start();        // C++ only
    void destroy() 
    // Override to implement semantics
    void process();
    // Override to implement channelRPC
    Service getService(PVStructure pvRequest)
    // methods called by code that accesses a record
    void lock();
    void unlock();
    boolean tryLock()
    void lockOtherRecord(PVRecordPtr const &amp; otherRecord);
    // method called when record is deleted.
    void detachClients();
    // methods called by code that changes data in a record.
    void beginGroupPut();
    void endGroupPut();
    // methods called by local provider
    boolean addPVRecordClient(PVRecordClientPtr const &amp; pvRecordClient);
    boolean removePVRecordClient(PVRecordClientPtr const &amp; pvRecordClient);
    // methods for pvCopy, i.e. to find fields that have changed value
    bool addListener(PVListener pvListener,PVCopy pvCopy);
    void nextMasterPVField(PVField pvField);
    boolean removeListener(PVListener pvListener,PVCopy pvCopy);
    // misc methods
    string getRecordName();
    PVStructure getPVStructure();
    PVRecordStructure getPVRecordStructure();
    PVRecordField findPVRecordField(PVField pvField);
    // methods for debugging output
    int getTraceLevel();
    void setTraceLevel(int level)
}
</pre>
where
<dl>
   <dt>create - C++ only</dt>
      <dd>Can be called to create a soft PVRecord.
       A soft record implements process by setting an optional top level timeStamp
       to the current time.
       <br />
       A derived class should have it's own static create method.
      </dd>
   <dt>PVRecord</dt>
      <dd>
     Constructor.
     <br />
     Create a PVRecord named recordName and that has pvStructure as it's top level structure.
     A derived class must call the base class constructor before performing any other
     initialization.
      </dd>
   <dt>~PVRecord - C++ only</dt>
      <dd>
      This calls destroy.
      </dd>
   <dt>init - C++ only</dt>
      <dd>
       Virtual method. Derived classes must implement this method.
       This method Must call initPVRecord.
      </dd>
   <dt>start - C++ only</dt>
      <dd>
       Virtual method. Optional method for derived class.
       It is called before record is added to database.
       The base method does nothing.
      </dd>
   <dt>destroy</dt>
      <dd>
      Destroy the PVRecord and any context.
      <br />
      Release any resources used and get rid of listeners and requesters.
      <br />
      If a derived class overrides this, it must call the base class destroy
      after it has destroyed any resorces it uses.
       <br />
      Destroy can be called for several reasons.
      Some examples are:
      <ul>
         <li>By pvDatabase when it is destroyed.</li>
         <li>By other code that wants to destroy the record.</li>
      </ul>
      </dd>
   <dt>process</dt>
      <dd>
      Virtual method.
      Derived classes usually implement this method.
      It implements the semantics for the record.
      <br />
      If a top level timeStamp exists the base class set it equal
       to the current time.
      </dd>
   <dt>getService</dt>
      <dd>
      A derived class implements this method if it supports channelRPC.
       It implements the semantics for the channelRPC.
      The base class returns null.
      </dd>
  <dt>lock and unlock</dt>
     <dd>Lock and Unlock the record.
        Any code accessing the data in the record or calling other PVRecord methods
        must have the record locked.</dd>
   <dt>tryLock</dt>
      <dd>If true then just like lock.
       If false client can not access record.
       A client can try to simultaneously hold the lock for more than two records
       by calling this method. But must be willing to accept failure.
       </dd>
   <dt>lockOtherRecord</dt>
      <dd>A client that holds the lock for one record can lock one other record.
        A client must not call this if the client already has the lock for
        more then one record.
      </dd>
   <dt>detachClients</dt>
     <dd>
        Ask all clients to detach from the record
      </dd>
   <dt>beginGroupPut</dt>
     <dd>Begin a group of puts.
     This results in all registered PVListeners being called</dd>
   <dt>endGroupPut</dt>
     <dd>End a group of puts.
       This results in all registered PVListeners being called.</dd>
   <dt>addPVRecordClient</dt>
     <dd>
      Every client that accesses the record must call this so that
      the client can be notified when the record is deleted.
     </dd>
   <dt>removePVRecordClient</dt>
     <dd>
      Client is no longer accessing the record.
     </dd>
   <dt>addListener</dt>
     <dd>
       Add a PVListener.
       This must be called before calling pvRecordField.addListener.
     </dd>
   <dt>nextMasterPVField</dt>
      <dd>
       Called by pvCopy monitor support.
      </dd>
   <dt>removeListener</dt>
     <dd>
       Removes a listener.
       The listener will also be removed from all fields to which it is attached.
      </dd>
   <dt>getRecordName</dt>
     <dd>Return the recordName.</dd>
   <dt>getPVStructure</dt>
     <dd>Get the top level PVStructure.</dd>
   <dt>getPVRecordStructure</dt>
     <dd>Get the top level PVRecordStructure.</dd>
   <dt>findPVRecordField</dt>
     <dd>Given a PVFieldPtr return the PVRecordFieldPtr for the field.</dd>
   <dt>getTraceLevel</dt>
      <dd>This can be used for debugging. There are currently three 
      levels that are used by existing code.
      <dl>
         <dt>0</dt>
            <dd>Produce no trace messages.</dd>
         <dt>1</dt>
            <dd>Issue a message to std::cout whenever anything is created
            or destroyed.</dd>
         <dt>2</dt>
            <dd>In addition to lifetime messages also issue a message
            whenever the record is accessed by pvAccess client.</dd>
      </dl>
      </dd>
   <dt>setTraceLevel</dt>
      <dd>Set the trace level. Note that special, described below.
       provides a record support that allows a pvAccess client
       to set the trace level of a record.</dd>
</dl>
<h3>Class PVDatabase</h3>
<pre>
class PVDatabase
{
     PVDatabase getMaster();  // C++ pnly
     PVDatabase();
     ~PVDatabase();      // C++ only
     destroy();
     PVRecord findRecord(String recordName);
     boolean addRecord(PVRecord record);
     boolean removeRecord(PVRecord record);
     string[] getRecordNames();
}

class PVDatabaseFactory
{
     PVDatabase getMaster();  // Java only
}
</pre>
where
<dl>
    <dt>getMaster</dt>
      <dd>
       Get the master database.
      <br />
       The master database is what provider <b>local</b> uses.
      </dd>
    <dt>PVDatabase</dt>
      <dd>
       Constructor.
      </dd>
    <dt>~PVDatabase C++ only</dt>
      <dd>
      Calls destroy;
      </dd>
   <dt>destroy</dt>
     <dd>
       This is called by remote channelAccess when process exits.
       This destroys and removes all records in the PVDatabase.
      </dd>
   <dt>findRecord</dt>
     <dd>Find a record. An empty pointer is returned if the record is not in the database.</dd>
   <dt>addRecord</dt>
     <dd>Add a record to the database.
        If the record already exists it is not modified and false is returned.</dd>
   <dt>getRecordNames</dt>
     <dd>Returns an array of all the record names.</dd>
   <dt>removeRecord</dt>
     <dd>Remove a record from the database.
       If the record was not in the database false is returned.</dd>
</dl>
<h3>TraceRecord</h3>
<p>An instance of TraceRecord provides the ability to remove another record in the local PVDatabase.
<b>exampleCPP</b> and <b>exampleJava</b> each has a submodule named <b>database</b>
that creates a PVDatabase that has a record named <b>PVRtraceRecord</b>.
It has the structure:</p>
<pre>
structure 
    structure argument
        string recordName 
        int level
    structure result
        string status 
</pre>
<p>It is designed to be used via a channelPutGet request but can also be used via pvget and pvput.
For example:
</p>
<pre>
pvget -m PVRtraceRecord
</pre>
<p>Then in another window:</p>
<pre>
pvput -r "argument{recordName,level}" PVRtraceRecord name level
</pre>
where
<dl>
   <dt>name</dt>
      <dd>The name of the record</dd>
   <dt>level</dt>
      <dd>The trace level, which should be one of 0, 1, 2.</dd>
</dl>
<p>For example if the command is:</p>
<pre>
pvput -r "argument{recordName,level}" PVRtraceRecord PVRdouble 2
</pre>
<p>Then the monitor will show:</p>
<pre>
pvget -m PVRtraceRecord
PVRtraceRecord
structure 
    structure argument
        string recordName 
        int level 0
    structure result
        string status 


PVRtraceRecord
structure 
    structure argument
        string recordName PVRdouble
        int level 2
    structure result
        string status success

</pre>
<p>Record <b>PVRdouble</b> will now show debug infomation when the record is accessed.
</p>
<h3>RemoveRecord</h3>
<p>An instance of RemoveRecord provides the ability to remove another record in the local PVDatabase.
<b>exampleCPP</b> and <b>exampleJava</b> each has a submodule named <b>database</b>
that creates a PVDatabase that has a record named <b>PVRremoveRecord</b>.
It has the structure:</p>
<pre>
structure 
    structure argument
        string recordName 
    structure result
        string status 
</pre>
<p>It is designed to be used via a channelPutGet request but can also be used via pvget and pvput.
For example:
</p>
<pre>
pvget -m PVRremoveRecord
</pre>
<p>Then in another window:</p>
<pre>
pvput -r "argument.recordName" PVRremoveRecord name
</pre>
where
<dl>
   <dt>name</dt>
      <dd>The name of the record to remove</dd>
</dl>
<p>For example if the command is:</p>
<pre>
pvput -r "argument.recordName" PVRremoveRecord PVRdouble
</pre>
<p>Then the monitor will show:</p>
<pre>
pvget -m PVRremoveRecord
PVRremoveRecord
structure 
    structure argument
        string recordName 
    structure result
        string status 


PVRremoveRecord
structure 
    structure argument
        string recordName PVRdouble
    structure result
        string status success
</pre>
<p>Record <b>PVRdouble</b> is no longer in the PVDatabase.
</p>

<h3>Channel Provider local</h3>
<p>This is code that provides an implementation of channelProvider as
defined by pvAccess.
It provides access to PVRecords and is accessed by the server side of remote pvAccess.
It uses the copy and monitor facilities from pvDataCPP and connects
them to a PVRecord.
</p>
<p>The implementation is a complete implementation of channelProvider
and channel.</p>
<p>The following provides a brief description of each channel method that
is implemented.</p>
<h4>channelProcessLocal</h4>
<p>Implements channelProcess.</p>
<h4>channelGetLocal</h4>
<p>Implements channelGet.</p>
<h4>channelPutLocal</h4>
<p>Implements channelPut.</p>
<h4>channelPutGetLocal</h4>
<p>Implements channelPutGet.</p>
<h4>channelArrayLocal</h4>
<p>Implements channelArray.</p>
<h4>ChannelRPCLocal</h4>
<p>Implements channelRPC.</p>
<h4>MonitorLocal</h4>
<p>This is the code that implements monitors on changes to fields of a PVRecord.
Because it is called by pvAccess client (monitor methods) and by
PVRecord (when postPut is called), it must be careful to prevent deadlocks.
The implementation is via class MonitorLocal (implemented in monitorFactory.cpp)
and PVCopyMonitor.
MonitorLocal is the interface between pvAccess and PVCopyMonitor.
PVCopyMonitor is the interface between MonitorLocal and PVRecord.
MonitorLocal manages a MonitorElement queue.
While monitoring is active (between start and stop) it keeps an active element
for use by PVCopyMonitor.
While monitoring is active PVCopyMonitor updates the active monitor element whenever
a postPut is issued to any field being monitored.
</p>
<p>The following two sections provide a few more details about MonitorLocal
and PVCopyMonitor.</p>
<h5>MonitorLocal</h5>
<p>MonitorLocal implements the following abstract base classes:</p>
<dl>
  <dt>Monitor</dt>
     <dd>This is described by pvDataCPP.
     It has methods start, stop, poll, and release.
      These methods are called by the pvAccess client
     </dd>
  <dt>PVCopyMonitorRequester</dt>
     <dd>This has methods releaseActiveElement and unlisten.
      These methods are called by PVCopyMonitor.
     </dd>
</dl>
MonitorLocal manages the following:
<dl>
  <dt>MonitorElementQueue</dt>
    <dd>This is a queue of monitor elements.
     A Queue is implemented by pvDataCPP and used by MonitorLocal.
     It is a finite queue.
     A monitor element is described by pvDataCPP.
     It has fields pvStructure, changedBitSet, and overrunBitSet.
     The pvStructure holds data for a subset of the fields in a PVRecord.
     The changedBitSet and overrunBitSet describe changes between
      monitor event.
      MonitorLocal creates an instance of PVCopy (implemented by pvDataCPP),
      which manages the interaction between the set of fields being
      monitored and the fields in the top level PVStructure of the PVRecord.
      pvCopy is also used to create the pvStructure for each monitor element.
      </dd>
  <dt>activeElement</dt>
    <dd>Whenever monitoring is active monitorLocal
     keeps an active element for use by pvCopyMonitor.
     It changes the active element based on calls to poll (by the
     client) and calls to releaseActiveElement (by pvCopyMonitor).
     If there are no free element when releaseActiveElement is
     called the current active element is returned.
     If a free element is available the client is notified that a new
      monitor element is available and the free element becomes the
    active element.
    </dd>
</dl>
<p>A brief description on each method in MonitorLocal is:</p>
<dl>
   <dt>start</dt>
     <dd>
        Called by client.
        With a lock held it clears the monitorElement queue
       and allocates an active element.
      With no lock held calls pvCopyMonitor-&gt;startMonitoring(activeElement)
     </dd>
   <dt>stop</dt>
      <dd>
        Called by client.
      With no lock held calls pvCopyMonitor-&gt;stopMonitoring(activeElement)
      </dd>
   <dt>poll</dt>
      <dd>
        Called by client.
       With a lock held it calls queue-&gt;getUsed();
      </dd>
   <dt>release</dt>
      <dd>
        Called by client.
       With a lock held it calls queue-&gt;releaseUsed();
      </dd>
   <dt>releaseActiveElement</dt>
      <dd>
       Called by PVCopyMonitor with no locks held.
       With a lock held it tries to get a new free element.
       If it can't it just returns the current active element.
       Otherwise it does the following.
       Using the activeElement it updates the pvStructure
        and compresses the changed and overrun bitSet.
       It then calls queue-&gt;setUsed(activeElement);
       It then sets the active element to the new free element.
        With no lock held it calls monitorRequester-&gt;monitorEvent(getPtrSelf())
       and finally returns the new active element,
      </dd>
   <dt>unlisten</dt>
      <dd>
       With no lock held it calls monitorRequester-&gt;unlisten(getPtrSelf());
      </dd>
</dl>
<h5>PVCopyMonitor</h5>
<p>
pvCopyMonitor is the code that manages changes to
fields in the record.
It is called by PVRecord whenever a postPut is issued to a field.
pvCopyMonitor uses the active monitor element provided by monitorFactory.
Note that this method is called with the record locked.
It only modifies the changedBitSet and overrunBitSet of the
active element but never modifies the pvStructure.
</p>
<p>A brief description of the pvCopyMonitor methods is:</p>
<dl>
  <dt>startMonitoring</dt>
     <dd>With no lock held it sets its monitorElement to the
     startElement passed by monitorLocal and calls pvRecord-&gt;addListener(getPtrSelf()).
     It locks the pvRecord.
      It calls calls addListener for every field in the record that is being
      monitored.
     It clears the overrun and changed bit sets.
     It sets bit 0 of the changed bit set and calls
     pvCopyMonitorRequester-&gt;releaseActiveElement();
     Thus the client will get the initial values for every field being monitored.
     The record is unlocked and the method returns to the caller.
      </dd>
  <dt>stopMonitoring</dt>
     <dd>
      With no lock held it calls pvRecord-&gt;removeListener(getPtrSelf());
     </dd>
  <dt>dataPut</dt>
     <dd>
      This is called because of a call to postPut.
      It is called with the record locked.
      It updates the changed and overrun bitSets.
      It isGroupPut is false it calls
      pvCopyMonitorRequester-&gt;releaseActiveElement().
      Otherwise it sets dataChanged true.
     </dd>
  <dt>beginGroupPut</dt>
     <dd>
      With a lock held it
      sets isGroupPut true and dataChanged false.
     </dd>
  <dt>endGroupPut</dt>
     <dd>
      With a lock held it sets isGroupPut false.
      With no lock held and dataChanged true it calls
      pvCopyMonitorRequester-&gt;releaseActiveElement()
     </dd>
  <dt>unlisten</dt>
     <dd>
      Just calls pvCopyMonitorRequester-&gt;unlisten();
     </dd>
</dl>
<h2>exampleJava and exampleCPP</h2>
<p>exampleJava and exampleCPP both have example databases.
Project exampleCPP has a database that is similar to exampleJava/
This section will mainly describe exampleCPP/database.
It shows how create a V3 IOC that has both V3 Records, PVRecords, and pvaSrv.
After reading this section the examples in exampleJava and exampleCPP should
be easy to understand.
</p>
<h3>Starting the example</h3>
<p>The example database can be run either as a standalone main program
or as part of a V3 IOC (Input Output Controller).
If as part of a V3 IOC the IOC has both V3 and V4 records.
It also starts pvaSrv so that the V3 records can be accessed via either
ca or pva.
</p>
<p>To run the example as a main program:</p>
<pre>
mrk> pwd
/home/epicsv4/exampleCPP/database
mrk> bin/linux-x86_64/exampleDatabaseMain 
</pre>
<p>To start the example as part of a V3 IOC:</p>
<pre>
mrk> pwd
/home/epicsv4/exampleCPP/database/iocBoot/exampleDatabase
mrk> ../../bin/linux-x86_64/exampleDatabase st.cmd
</pre>
<p>Once the database is running then the following can access exampleHello:</p>
<pre>
pvput -r "argument" PVRhelloPutGet World
pvget -r "result.value" PVRhelloPutGet
exampleHello
structure 
    structure result
        string value Hello World
</pre>
<h3>source code</h3>
<p> <b>exampleCPP/database/src</b> has the following examples:</p>
<dl>
   <dt>exampleHello</dt>
      <dd>This is an hello world example that is meant to be accesed via
      a channelPutGet request. It can also be accessed via pvput
      followed by a pvget.</dd>
   <dt>exampleHelloRPC</dt>
       <dd>
         The is an hello world example that is accessed via a channelRPC request.
       </dd>
   <dt>exampleDatabase</dt>
      <dd>This creates an exampleHello record.
       It also creates a large set of records of all possible types that
       have only the default process semantics, which only sets the timeStamp when
       the record is processed.
      </dd>
</dl>

The src directory also has the following files:
<dl>
   <dt>exampleDatabaseMain.cpp</dt>
      <dd>code to run example as main program</dd>
   <dt>exampleDatabaseInclude.dbd<br />
       exampleDatabaseRegister.cpp</dt>
      <dd>code to run example as part of V3 IOC</dd>
</dl>
<h4>exampleDatabaseMain.cpp</h4>
<p>This is the file that runs the example as a main program.
The main program is:</p>
<pre>
int main(int argc,char *argv[])
{
    PVDatabasePtr master = PVDatabase::getMaster();
    ChannelProviderLocalPtr channelProvider = getChannelProviderLocal();
    ExampleDatabase::create();
    ServerContext::shared_pointer ctx =
        startPVAServer("local",0,true,true);
    cout &lt;&lt; "exampleDatabase\n";
    string str;
    while(true) {
        cout &lt;&lt; "Type exit to stop: \n";
        getline(cin,str);
        if(str.compare("exit")==0) break;

    }
    ctx->destroy();
    return 0; 
}
</pre>
The only code that is not generic is:
<pre>
    ExampleDatabase::create();
</pre>
<h3>exampleDatabaseRegister.cpp</h3>
This is used to create an iocshell command to start the example database as part
of a V3 IOC.
It is almost generic.
The guts of the code is:
<pre>
static const iocshFuncDef exampleDatabaseFuncDef = {"exampleDatabase", 0};

static void exampleDatabaseCallFunc(const iocshArgBuf *args)
{
    ExampleDatabase::create();
}

static void exampleDatabaseRegister(void)
{
    static int firstTime = 1;
    if (firstTime) {
        firstTime = 0;
        iocshRegister(&amp;exampleDatabaseFuncDef, exampleDatabaseCallFunc);
    }
}

extern "C" {
    epicsExportRegistrar(exampleDatabaseRegister);
}
</pre>
Other than <b>exampleDatabase</b> as part of the names it is boiler plate code.
<h3>exampleDatabaseInclude.dbd</h3>
This is just:
<pre>
registrar("exampleDatabaseRegister")
</pre>
It again is generic except for <b>exampleDatabase</b> as part of the name.
<h3>Makefile</h3>
Look at the Makefile to see how other files.
<h3>exampleDatabase</h3>
<b>exampleDatabase.h</b> is almost completely generic.
It has the code:
<pre>
class epicsShareClass  ExampleDatabase{
public:
    static void create();
};
</pre>
It defines a factory methods for creating the example database.
<p>
<b>exampleDatabase.cpp</b> is not generic.
It shows how to create records of various types.
Most of the records have only the default process method.
The default process does nothing except that if a timeStamp field is present
the time is set to the current time.
Look at the code to see examples of how to create records.
</p>
<h3>exampleCPP/database/ioc</h3>
This directory has two subdirectories:
<dl>
  <dt>Db</dt>
    <dd>This creates some V3 records.</dd>
  <dt>src</dt>
    <dd>This has to files to load the V3 and V4 support for a V3 IOC.</dd>
</dl>
<h4>src</h4>
<p>exampleDatabaseMain.cpp is standard code to start a V3 IOC</p>
<p>exampleDatabaseInclude.dbd contains:</p>
<pre>
include "base.dbd"
include "PVAServerRegister.dbd"
include "registerChannelProviderLocal.dbd"
include "dbPv.dbd"
registrar("exampleDatabaseRegister")
</pre>
<p><b>base.dbd</b> is standard way to include the base V3 code.
<b>PVAServerRegister.dbd</b> is how the pvAccess Server code is included.
<b>registerChannelProviderLocal.dbd</b> is how the local pva server is started.
The local server is implemented by pvDatabaseCPP.
<b>dbPv.dbd</b> is how dbPv, the  server that accesses V3 revords, is started.
</p>
<p><b>registrar("exampleDatabaseRegister")</b> is the only example specific statement.
It is used to start the example database.</p>
<h3>exampleCPP/database/iocBoot/exampleDatabase</h3>
<p>This is where the V3 IOC is started.
The <b>st.cmd</b> starts with normal way to start a V3 IOC.
What is different is the statements after iocInit:</p>
<pre>
exampleDatabase
startPVAServer
</pre>
<p>The first statement creates the example database.
The second statement starts the pva server.
After it is started clients can access the V4 records and the V3 records via pva.
</p>

<h2>API: pvAccess</h2>
<h3>ChannelProvider</h3>
<pre>
ChannelProviderRegistry
    ChannelProvider getProvider(string providerName)
    ChannelProvider createProvider(string providerName)
    string[] getProviderNames()

ChannelProvider
    string getProviderName()
    ChannelFind channelFind(
        string channelName,
        ChannelFindRequester channelFindRequester)
    ChannelFind channelList(
        ChannelListRequester channelListRequester)
    Channel createChannel(
         string channelName,
         ChannelRequester,
         short priority)
    Channel createChannel(
         string channelName,
         ChannelRequester channelRequester,
         short priority,
         string address)

ChannelFindRequester
    void channelFindResult(
        Status status,
        ChannelFind channelFind,
        boolean wasFound)

ChannelFind
    ChannelProvider getChannelProvider()
     void cancelChannelFind()
</pre>

<h4>ChannelProviderRegistry</h4>
<dl>
  <dt>getProvider</dt>
    <dd>This gets the requested provider.Two providers are registered automatically:
     <b>pva</b>, which uses the pvAccess network protocol, and <b>ca</b>,
      which uses the Channel Access network protocol.
     </dd>
  <dt>createProvider</dt>
    <dd>This registers a ChannelProvider. User code does not call this,
      e.g. it is called via code that implements the ChannelProvider interface.
    </dd>
  <dt>getProviderNames</dt>
    <dd>Returns the names of the providers that have been created.</dd>
</dl>

<h4>ChannelProvider</h4>
<dl>
  <dt>destroy</dt>
    <dd>The channel provider will shutdown and remove all resources it is
    using.</dd>
  <dt>getProviderName</dt>
    <dd>Get the name of the provider.</dd>
  <dt>channelFind</dt>
    <dd>Find a channel. The details are described in this section.</dd>
  <dt>createChannel</dt>
    <dd>Create a channel. A Channel is described in the next section.</dd>
</dl>

<h4>ChannelFindRequester</h4>
<dl>
  <dt>channelFindResult</dt>
    <dd>This is called by the implementation. It may or may not get called. For
      a remote call it is normally called only if the channel is found. A local
      provider will usually call it immediately and report if it has the
      requested channel. Thus this can be called before the channelFind method
      returns.</dd>
</dl>

<h4>ChannelFind</h4>
<p>This method is to be used to by local pvAccess implementations (e.g.
pvAccess server queries pvIOCJava. A client can determine if a channel exists
without creating a channel. The client must implement a requester interface and
the implementation provides an interface that the client can use to cancel the
request.</p>
<dl>
  <dt>getChannelProvider</dt>
    <dd>Get the channel provider.</dd>
  <dt>cancelChannelFind</dt>
    <dd>Cancel the find request.</dd>
</dl>

<h3>Channel</h3>
<pre>
ChannelRequester extends Requester
    void channelCreated(
        Status status,
        Channel channel)
    void channelStateChange(
        Channel channel,
        ConnectionState connectionState)

enum AccessRights {
    none,
    read,
    readWrite
}

Channel extends Requester
    ChannelProvider getProvider()
    string getRemoteAddress()
    ConnectionState getConnectionState()
    void destroy()
    string getChannelName()
    ChannelRequester getChannelRequester()
    boolean isConnected()
    AccessRights getAccessRights(PVField pvField)
    void getField(GetFieldRequester requester,string subField)
    ChannelProcess createChannelProcess(
        ChannelProcessRequester channelProcessRequester,
        PVStructure pvRequest)
    ChannelGet createChannelGet(
        ChannelGetRequester channelGetRequester,
        PVStructure pvRequest)
    ChannelPut createChannelPut(
        ChannelPutRequester channelPutRequester,
        PVStructure pvRequest)
    ChannelPutGet createChannelPutGet(
        ChannelPutGetRequester channelPutGetRequester,
        PVStructure pvRequest)
    ChannelRPC createChannelRPC(
        ChannelRPCRequester channelRPCRequester,
        PVStructure pvRequest)
    ChannelArray createChannelArray(
        ChannelArrayRequester channelArrayRequester,
        PVStructure pvRequest)
    Monitor createMonitor(
        MonitorRequester MonitorRequester,
        PVStructure pvRequest)
</pre>
<h4>ChannelRequester</h4>
<p>
The caller must implement the interface ChannelRequester.
</p>
<dl>
  <dt>Requester</dt>
    <dd>This is defined in package org.epics.pvdata.pv. It has two methods:
      getRequesterName and message.</dd>
  <dt>channelCreated</dt>
    <dd>This is called when a channel has been created. The argument provides
      the channel unless status was not success.</dd>
  <dt>channelStateChange</dt>
    <dd>A channel connection state change has occurred. This is called the first
      time when a channel has been created and connected to a server or
      destroyed.</dd>
</dl>

<h4>Channel</h4>
<p>where</p>
<dl>
  <dt>getProvider</dt>
    <dd>Get the provider.</dd>
  <dt>getRemoteAddress</dt>
    <dd>Get the network address of the server.</dd>
  <dt>destroy</dt>
    <dd>Destroy the channel and all resources used by the channel.</dd>
  <dt>getChannelName</dt>
    <dd>The name of the channel, e.g. the name if the PVRecord.</dd>
  <dt>getChannelRequester</dt>
    <dd>Get the channel requester. This is normally called by the
      implementation rather than the client.</dd>
  <dt>isConnected</dt>
    <dd>Is the channel connected?</dd>
  <dt>getAccessRights</dt>
    <dd>Get the access rights for the channel.</dd>
</dl>
<p>The remaining methods are described in later sections of this package
overview.</p>

<p>Many of the interface described in the later sections are created via a
create call that has as one of it's arguments:
</p>
<pre>PVStructure pvRequest</pre>
<p>This is also discussed in a later section.</p>

<h3>GetField</h3>

<p>The method:</p>
<pre>    Channel.getField(GetFieldRequester requester, String subField);</pre>

<p>Gets the introspection interface for the specified sub field of the record
it which the channel is connected. The subField can be null, which means get
the introspection interface for the entire record, or is of the form
"name.name..." . Thus it can be a request for any field within a record. The
requester must implement the interface:</p>
<pre>interface GetFieldRequester extends Requester {
    void getDone(Status status, Field field);
}</pre>

<p>where</p>
<dl>
  <dt>getDone</dt>
    <dd>A getField request has finished. A null is returned if the request
      fails and status contains a reason of a failure. If the request succeeds
      Field is the introspection interface. </dd>
</dl>

<h3>ChannelRequest</h3>

<p>Many of the interfaces described in later sections extend the following
interface.</p>
<pre>
interface ChannelRequest extends Lockable, Destroyable {
    Channel getChannel();
    void cancel();
    void lastRequest();
</pre>

<p>where</p>
<dl>
  <dt>destroy</dt>
    <dd>Destroy whatever the extended interface implements. It will free all
      resources it uses.</dd>
  <dt>getChannel</dt>
     <dd>Get the channel instance to which this request belongs.</dd>
  <dt>cancel</dt>
     <dd>Cancel the current request.</dd>
  <dt>lastRequest</dt>
     <dd>The next request will be the last request.</dd>
</dl>


<h3>ChannelProcess</h3>
<p>A ChannelProcess is created via a call to:</p>
<pre>interface Channel extends Requester {
   ChannelProcess createChannelProcess(
       ChannelProcessRequester channelProcessRequester);
}</pre>
<p>The definition is:</p>
<pre>
ChannelProcessRequester extends Requester
    void channelProcessConnect(
        Status status,
        ChannelProcess channelProcess)
    void processDone(
        Status status,
        ChannelProcess channelProcess)

ChannelProcess extends ChannelRequest
    void process()
</pre>
<h4>ChannelProcessRequester</h4>
<p>The requester must implement this interface.</p>
<dl>
  <dt>channelProcessConnect</dt>
    <dd>This returns the interface for requesting that a record be processed.
      Status is the result for the create request. channelProcess is null if
      status is not success.</dd>
  <dt>processDone</dt>
    <dd>This is called when a process request is done. Status is the result for
      the process request. </dd>
</dl>

<h4>ChannelProcess</h4>
<dl>
  <dt>process</dt>
    <dd>Process the record.
      Another process request must not be issued until processDone is
      called.</dd>
</dl>

<h3>ChannelGet</h3>
<p>A ChannelGet is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelGet createChannelGet(
        ChannelGetRequester channelGetRequester,
        PVStructure pvRequest);
}</pre>
<p>The definition is:</p>
<pre>
ChannelGetRequester extends Requester
    void channelGetConnect(
        Status status,
        ChannelGet channelGet,
        Structure structure)
    void getDone(
        Status status,
        ChannelGet channelGet,
        PVStructure pvStructure,
        BitSet bitSet)

ChannelGet extends ChannelRequest
    void get()
</pre>
<h4>ChannelGetRequester</h4>
<dl>
  <dt>channelGetConnect</dt>
    <dd>This is called if the createProcess fails or when the client request is
      connected to the server. Status provides the result of the createChannel
      request. If status is not success than the other arguments are null.
      channelGet is the interface for requesting gets. structure is the
      introspection interface for data that is returned to getDone.
    </dd>
  <dt>getDone</dt>
    <dd>The get request is done. status provides the result of the get request.
      If successful the pvStructure and bitSet contain the data returned
      as a result of a get request.
      bitSet shows which fields have new data. If a
      bit of bitSet is set for a structure field that means that all fields of
      the structure have new values. For example of bit 0 of bitSet is set then
      all fields of pvStructure have new data. Note that each PVField
      implements a method getFieldOffset(). this can be used with bitSet to
      determine which fields have new data values. See BitSet and PVField in
      org.epics.pvdata for details.
      </dd>
</dl>

<h4>ChannelGet</h4>
<dl>
  <dt>get</dt>
    <dd>Get data.
       Another get
      request must not be issued until getDone is called.</dd>
</dl>

<h3>ChannelPut</h3>
<p>A ChannelPut is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelPut createChannelPut(
        ChannelPutRequester channelPutRequester,
        PVStructure pvRequest);
}</pre>
<p>The definition is:</p>

<pre>
ChannelPutRequester extends Requester
    void channelPutConnect(
        Status status,
        ChannelPut channelPut,
        Structure structure)
    void putDone(
        Status status,
        ChannelPut channelPut)
    void getDone(
        Status status,
        ChannelPut channelPut,
        PVStructure pvStructure,
        BitSet bitSet)

ChannelPut extends ChannelRequest
    void put(PVStructure pvPutStructure, BitSet bitSet)
    void get()
</pre>
<h4>ChannelPutRequester</h4>
<p>The requester must implement this interface.</p>
<dl>
  <dt>channelPutConnect</dt>
    <dd>This is called if the createChannelPut fails or when the client request
      is connected to the server. Status provides the result of the
      createChannelPut request. If status is not success than the other
      arguments are null. channelPut is the interface for requesting puts and
      gets. Structure is the introspection interface that must be used
      for data that is put to the server or that is returned by a get request.
      </dd>
  <dt>putDone</dt>
    <dd>The put request is done. status provides the result of the put request.
    </dd>
  <dt>getDone</dt>
    <dd>The get request is done. status provides the result of the put request.
      pvStructure has the data returned from the server.
      bitSet to shows which fields have new data before making a put request.
      If a bit of bitSet is set for a structure field that means that all
      fields of the structure have new values. For example of bit 0 of bitSet
      is set then all fields of pvStructure have new data. Note that each
      PVField implements a method getFieldOffset(). this can be used with
      bitSet to determine which fields have new data values. See BitSet and
      PVField in org.epics.pvdata for details.
    </dd>
</dl>

<h4>ChannelPut</h4>
<dl>
  <dt>put</dt>
    <dd>Put data.
      pvPutStructure is the data to send to the server,
      bitSet determines which fields are sent.
     </dd>
  <dt>get</dt>
    <dd>Get the current data from the record. The record is never processed.
      The request just gets the current values which is put into the
      pvStructure returned in the call to channelPutConnect.</dd>
</dl>
<p>NOTE: Only one of put and get can be outstanding at the same time.
  Another get or put must not be issued until getDone or putDone is called.</p>

<h3>ChannelPutGet</h3>
<p>A channelPutGet request puts data into a record, optionally processes the
record, and gets data from the record.</p>

<p>A channel putGet is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelPutGet createChannelPutGet(
        ChannelPutGetRequester channelPutGetRequester,
        PVStructure pvRequest);
}</pre>

<p>The definition is:</p>
<pre>
ChannelPutGetRequester extends Requester
    void channelPutGetConnect(
        Status status,
        ChannelPutGet channelPutGet,
        Structure putStructure,
        Structure getStructure)
    void putGetDone(
        Status status,
        ChannelPutGet channelPutGet,
        PVStructure getPVStructure,
        BitSet getBitSet)
    void getPutDone(
        Status status,
        ChannelPutGet channelPutGet,
        PVStructure putPVStructure,
        BitSet putBitSet)
    void getGetDone(
        Status status,
        ChannelPutGet channelPutGet,
        PVStructure getPVStructure,
        BitSet getBitSet)

ChannelPutGet extends ChannelRequest
    void putGet(PVStructure pvPutStructure, BitSet putBitSet)
    void getPut()
    void getGet()
</pre>
<h4>ChannelPutGetRequester</h4>
<p>The requester must implement this interface.</p>
<dl>
  <dt>channelPutGetConnect</dt>
    <dd>This is called if the createChannelPutGet fails or when the client
      request is connected to the server. Status provides the result of the
      createChannelPutGet request. If status is not success than the other
      arguments are null. channelPutGet is the interface for requesting putGet,
      getPut and getGet. putStructure is the introspection interface
      that is used for data sent by the client and getStructure the introspection
      interface for data received by the client.
     </dd>
  <dt>putGetDone</dt>
    <dd>The putGet request is done.
     If status is not success then the other arguments may be null.
     getPVStructure is the data returned to the client and getBitSet shows
     which fields have changed value since the last putGet request.
    </dd>
  <dt>getPutDone</dt>
    <dd>The getPut request is done.
     If status is not success then the other arguments may be null.
     putPVStructure is the data returned to the client and putBitSet shows
     which fields have changed value since the last getPut request.
    </dd>
  <dt>getGetDone</dt>
    <dd>The getGet request is done.
     If status is not success then the other arguments may be null.
     getPVStructure is the data returned to the client and getBitSet shows
     which fields have changed value since the last getGet request.
    </dd>
</dl>
<h4>ChannelPutGet</h4>
<dl>
  <dt>putGet</dt>
    <dd>First put the pvPutStructure data into the record. Then if process is
      true process the record. Finally get data from the record and put it into
      pvGetStructure.
    </dd>
  <dt>getPut</dt>
    <dd>Get current put data from the record and put it into pvPutStructure. The
      record is never processed.
    </dd>
  <dt>getGet</dt>
    <dd>Get current data from the record and put it into pvGetStructure. The
      record is never processed.
    </dd>
</dl>

<p>NOTE: Only one of putGet, getPut, or getGet can be outstanding at the same
time. Another request must not be issued until the appropriate xxxDone is
called.</p>

<h3>ChannelArray</h3>
<p>ChannelArray provides the ability to read or write a sub-array of an array
field in a record. Note that all the other transfer methods can also read or
write arrays but always transfer entire arrays. ChannelArray provides the
ability to transfer a subarray. A ChannelArray is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelArray createChannelArray(
        ChannelArrayRequester channelArrayRequester,
        PVStructure pvRequest);
}</pre>

<p>The definition is:</p>
<pre>
ChannelArrayRequester extends Requester
    void channelArrayConnect(
        Status status,
        ChannelArray channelArray,
        Array array)
    void putArrayDone(
        Status status,
        ChannelArray channelArray)
    void getArrayDone(
        Status status,
        ChannelArray channelArray,
        PVArray pvArray)
    void getLengthDone(
        Status status,
        ChannelArray channelArray,
        int length,
        int capacity)
    void setLengthDone(
        Status status,
        ChannelArray channelArray)

ChannelArray extends ChannelRequest
    void putArray(
        PVArray putArray,
        int offset,
        int count,
        int stride)
    void getArray(
        int offset,
        int count,
        int stride)
    void getLength()
    void setLength(
        int length)
</pre>

<h4>ChannelArrayRequester</h4>
<p>The requester must implement this interface.</p>
<dl>
  <dt>channelArrayConnect</dt>
    <dd>This is called if the createChannelArray fails or when the client
      request is connected to the server. Status provides the result of the
      createChannelArray request. If status is not success than the other
      arguments are null. channelArray is the interface for requesting puts and
      gets. array is the interface for the data that transfered between client
      and server.
    </dd>
  <dt>putArrayDone</dt>
    <dd>The put request is done.</dd>
  <dt>getArrayDone</dt>
    <dd>The get request is done.
      pvArray holds the data.</dd>
  <dt>getLengthDone</dt>
     <dd>The getLength request is done. length and capacity hold the result.</dd>
  <dt>setLengthDone</dt>
     <dd>The setLength request is done.</dd>
</dl>
<h4>ChannelArray</h4>
<dl>
  <dt>putArray</dt>
    <dd>Put array data. The offset and stride are the offset and
      stride in the server and the count is
      the total number of elements to write.
     </dd>
  <dt>getArray</dt>
    <dd>Get array data. The offset and stride are the offset and
      stride in the server and the count is
      the total number of elements to read.
    </dd>
  <dt>getLength</dt>
    <dd>Get the current length and capacity of the array in the server.</dd>
  <dt>setLength</dt>
    <dd>Set the length and capacity of the array in the server.</dd>
</dl>


<h3>Monitor</h3>
<p>Monitor provides the ability to set monitors on data in a PVRecord. What
triggers a monitor depends on the monitor support in the server. The standard
server provides support for the following: onPut, onChange, onAbsoluteChange,
and onPercentChange.</p>

<p>A Monitor is created via a call to:</p>
<pre>    void createMonitor(
        MonitorRequester monitorRequester,
        PVStructure pvRequest);
}</pre>
<p>The definition is:</p>

<pre>
MonitorRequester extends Requester
    void monitorConnect(Status status, Monitor monitor, Structure structure))
    void monitorEvent((Monitor monitor)
    void unlisten()

Monitor
    Status start()
    Status stop()
    MonitorElement poll()
    void release(MonitorElement monitorElement)

MonitorElement
    PVStructure getPVStructure()
    BitSet getChangedBitSet()
    BitSet getOverrunBitSet()
</pre>
<h4>MonitorRequester</h4>
<p>The requester must implement this interface.</p>
<dl>
  <dt>monitorConnect</dt>
    <dd>This is called if the createMonitor fails or when the client request is
      connected to the server.
       <dl>
           <dt>status</dt>
             <dd>The result of the createMonitor request.
                If status is not success than the other arguments are null.
             </dd>
           <dt>monitor</dt>
               <dd>The interface for the Monitor.</dd>
           <dt>structure</dt>
               <dd>The introspection interface for the data that will
                be returned for each monitor event.</dd>
        </dl>
    </dd>
  <dt>monitorEvent</dt>
    <dd>monitorEvent is called when a monitor occurs. The client must call
      monitor.poll to get data for the monitor. See below. </dd>
  <dt>unlisten</dt>
    <dd>The server has issued an unlisten request.</dd>
</dl>
<p>The following is the Monitor interface which is defined in project pvData</p>
<pre>interface Monitor extends Destroyable {
    Status start();
    Status stop();
    MonitorElement poll();
    void release(MonitorElement monitorElement);
}</pre>

<p>where</p>
<dl>
  <dt>start</dt>
    <dd>Start monitoring</dd>
  <dt>stop</dt>
    <dd>Stop monitoring</dd>
  <dt>poll</dt>
    <dd>Poll for monitor event. Null is returned when no more events are
      available. The client must call this method in order to get monitor
    data.</dd>
  <dt>release</dt>
    <dd>When the client has processed the monitor event returned by poll the
      client must call release before again calling poll.</dd>
</dl>
<p>A monitorElement is defined as:</p>
<pre>interface MonitorElement {
    PVStructure getPVStructure();
    BitSet getChangedBitSet();
    BitSet getOverrunBitSet();
}</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>The data structure.</dd>
  <dt>getChangedBitSet</dt>
    <dd>A bitset which has a bit set for each field of the data structure which
      has changed since the last monitor.</dd>
  <dt>getOverrunBitSet</dt>
    <dd>A bitset which has a bit set for each field of the data structure which
      has changed more than once since the last monitor.</dd>
</dl>
<h4>Monitor</h4>
<dl>
  <dt>start</dt>
    <dd>Start monitoring</dd>
  <dt>stop</dt>
    <dd>Stop monitoring</dd>
  <dt>poll</dt>
    <dd>Poll for monitor event. Null is returned when no more events are
      available. The client must call this method in order to get monitor
    data.</dd>
  <dt>release</dt>
    <dd>When the client has processed the monitor event returned by poll the
      client must call release before again calling poll.</dd>
</dl>


<h3>ChannelRPC</h3>
<p>A ChannelRPC is like a channelPutGet except that a completely different
pvStructure can be sent and returned for each request. It is created via a call to:</p>
<pre>interface Channel extends Requester {
    ChannelRPC createChannelRPC(
        ChannelRPCRequester channelRPCRequester,
        PVStructure pvRequest);
}</pre>
<p>The definition is:</p>
<pre>
ChannelRPCRequester extends Requester
    void channelRPCConnect(
        Status status,
        ChannelRPC channelRPC)
    void requestDone(
        Status status,
        ChannelRPC channelRPC,
        PVStructure pvResponse)

ChannelRPC extends ChannelRequest
    void request(PVStructure pvArgument)
</pre>
<h4>ChannelRPCRequester</h4>
<p>The requester must implement this interface.</p>
<dl>
  <dt>channelRPCConnect</dt>
    <dd>Status provides the result of the createChannelRPC request. If status
      is not success than the other argument is null.</dd>
  <dt>requestDone</dt>
    <dd>The request is done. status provides the result of the request. If
      successful a pvResponse is returned. </dd>
</dl>
<h4>ChannelRPC</h4>
<dl>
  <dt>request</dt>
    <dd>pvArgument is the structure that is sent to the server. If lastRequest
      is true than it is a one time request, i.e. Send it is the same as
      calling destroy after the request is complete.</dd>
</dl>





<h2>API: pvaSrv</h2>
<p>pvaSrv implements channel provider <b>dbPv</b> that runs in the EPICS V3 IOC</p>
<p><b>dbPv</b> allows you to get, put and monitor V3 PVs (fields of EPICS DB records) over pvAccess, translating the value and its meta data (graphics limits, alarm status, timestamp) to or from V4 Normative Type (NT) pvData structures (NTScalar, NTScalarArray).</p>

<h2>API: pvaPy</h2>
<p><b>pvaPy</b> provides a python interface to pvData and pvAccess.</p>
<p>The following:</p>
<pre>
#!/usr/bin/env python

from pvaccess import Channel

c = Channel('double01')
oldValue = c.get().getDouble()
print 'Got old value: ', oldValue
value = oldValue + 1.1
print 'Putting value via putDouble(): ', value
c.putDouble(value) 
newValue = c.get().getDouble()
print 'Got new value: ', newValue
</pre>
produces:
<pre>
python examplePut.py
Got old value:  5.3
Putting value via putDouble():  6.4
Got new value:  6.4
</pre>

<h2>pvAccess Channel Providers.</h2>
<p>pvAccessJava and pvAccessCPP implement the following providers:</p>
<dl>
   <dt>pva</dt>
     <dd>This is a provider that trasfers data via the network protocol defined in
    <a href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html">pvAccess Protocol Specification </a>
     <br/>
      This provides the client and server side of the network protocol.
      The client side is a complete implementation.
      The server side requires additional code to access data sources but takes care of all network code.
     </dd>
    <dt>ca</dt>
      <dd>This is client support for transfering data via the EPICS V3 channel access protocol.
      </dd>
</dl>
<p>Providers can be provided for other data sources.
A provider must implement ChannelProvider and Channel.
pvAccess supports an arbitrary number of providers.
On the server side of remote pvAccess providers must be implemented,
because it calls the providers to implement the CHannel methods.
</p>
<p>
At present C++ provides two server side providers:
</p>
<dl>
   <dt>pvaSrv</dt>
      <dd>This is a pvAccess server that accesses V3 records,</dd>
   <dt>local</dt>
      <dd>This is implemented by pvDatabaseCPP</dd>
</dl>
<p>
At present Java provides one server side provider:
</p>
<dl>
   <dt>local</dt>
      <dd>This is implemented by pvDatabaseJava</dd>
</dl>
<h2>Convert Facility</h2>
<p>Both pvDataJava and pvDataCPP have a Convert Facility.
Although they have some common features they are different enough that they
will be discussed separately.
</p>
<p>
They main difference is support for scalar arrays.
</p>
<p>
The Java Convert facility supports sub-array copies between any two numeric
arrays.
It does a deep copy except for a complete copy between two array of the same
type and the source array is immutable.
In this case to calls the shareData method and also makes the destination
array immutable.
</p>
<p>
The C++ faclity only supports complete array copies between 
two scalar arrays of the same type and only does a shallow copy.
It also does a shallow copy for union, unionArray, and structureArray fields.
It also has a separate facility that does sub-array copies between two
arrays of the same type.
</p>
<h3>Java</h3>
<p><b>NOTE:</b> copying immutable array fields. If an entire immutable array
field is copied to another array that has the same elementType, both offsets
are 0, and the length is the length of the source array, then the shareData
method of the target array is called and the target array is set immutable.
Thus the source and target share the same primitive array.</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following.
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
  <li>Conversion between compatible unions.</li>
  <li>Conversion between compatible union arrays.</li>
  <li>Conversion between compatible structure arrays.</li>
  <li>Support for unsigned integers. Because Java does primitive unsigned
   integers the only support is in "widening" operations.
   For example if a PVUByte is converted to short then the proper conversion will
   be done.</li>
  <li>A utility method the returns the full field name of a field.</li>
</ul>
<pre>
interface Convert {
    void getFullFieldName(StringBuilder builder,PVField pvField)
    void getString(StringBuilder buf,PVField pv, int indentLevel);
    void getString(StringBuilder buf,PVField pv);
    void fromString(PVScalar pv,String from);
    void fromString(PVScalarArray pv,String from);
    int fromStringArray(PVScalarArray pv,
         int offset, int len, String[]from, int fromOffset);
    int toStringArray(PVScalarArray pv,
         int offset, int len, String[]to, int toOffset);
    boolean isCopyCompatible(Field from, Field to);
    void copy(PVField from,PVField to);
    boolean isCopyScalarCompatible(Field from, Field to);
    void copyScalar(PVField from, PVField to);
    boolean isCopyScalarArrayCompatible(ScalarArray from, ScalarArray to);
    int copyScalarArray(PVScalarArray from, int offset,
         PVScalarArray to, int toOffset, int len);
    boolean isCopyStructureCompatible(Structure from, Structure to);
    void copyStructure(PVStructure from, PVStructure to);
    boolean isCopyUnionCompatible(Union from, Union to);
    void copyUnion(PVUnion from, PVUnion to);
    boolean isCopyStructureArrayCompatible(StructureArray from, StructureArray to);
    void copyStructureArray(PVStructureArray from, PVStructureArray to);
    boolean isCopyUnionArrayCompatible(UnionArray from, UnionArray to);
    void copyUnionArray(PVUnionArray from, PVUnionArray to);
    // For the following the pv Type must be PVByte, ...., PVDouble
    byte toByte(PVField pv);
    short toShort(PVField pv);
    int   toInt(PVField pv);
    long  toLong(PVField pv);
    float toFloat(PVField pv);
    double toDouble(PVField pv);
    String toString(PVScalar pv);
    void  fromByte(PVField pv, byte from);
    void  fromShort(PVField pv, short from);
    void  fromInt(PVField pv, int from);
    void  fromLong(PVField pv, long from);
    void  fromUByte(PVField pv, byte from);
    void  fromUShort(PVField pv, short from);
    void  fromUInt(PVField pv, int from);
    void  fromULong(PVField pv, long from);
    void  fromFloat(PVField pv, float from);
    void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
    int toByteArray(PVScalarArray pv,
        int offset, int len, byte[]to, int toOffset);
    int toShortArray(PVScalarArray pv,
        int offset, int len, short[]to, int toOffset);
    int toIntArray(PVScalarArray pv,
        int offset, int len, int[]to, int toOffset);
    int toLongArray(PVScalarArray pv,
        int offset, int len, long[]to, int toOffset);
    int toFloatArray(PVScalarArray pv,
        int offset, int len, float[]to, int toOffset);
    int toDoubleArray(PVScalarArray pv,
        int offset, int len, double[]to, int toOffset);
    int fromByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromLongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromUByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromUShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromUIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromULongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromFloatArray(PVScalarArray pv,
        int offset, int len, float[]from, fromOffset);
    int fromDoubleArray(PVScalarArray pv,
        int offset, int len, double[]from, fromOffset);
    void newLine(StringBuilder builder, int indentLevel);
}
</pre>
<p>The array methods all return the number of elements copied or converted.
This can be less than <span>len</span> if the
PVField array contains less than len elements.</p>

<p><span>newLine</span> is a convenience method
for code that implements <span>toString</span> It
generates a newline and inserts blanks at the beginning of the newline.</p>

<p>The getString methods dump the data in the metadata syntax described in the
pvData project overview. Note that the toString methods of PVField are
implemented by calling these convert methods.</p>

<h3>C++</h3>
<p>Many of the Java convert methods have been moved to <b>class PVField</b> and it's extensions.
This include all the comparison methods and also conversion between numeric types.
</p>
<h4>convert.h</h4>

<pre>
class Convert;
typedef std::tr1::shared_ptr&lt;Convert&gt; ConvertPtr;

class Convert {
public:
    static ConvertPtr getConvert();
    ~Convert();
    void getString(std::string * buf,PVFieldPtr const &amp; pvField,int indentLevel);
    void getString(std::string * buf,PVFieldPtr const &amp; pvField);
    void getString(std::string * buf,PVField const * pvField,int indentLevel);
    void getString(std::string * buf,PVField const * pvField);
    std::size_t fromString(
        PVStructurePtr const &amp;pv,
        StringArray const &amp; from,
        std::size_t fromStartIndex = 0);
    void fromString(PVScalarPtr const &amp; pv, std::string const &amp; from);
    std::size_t fromString(PVScalarArrayPtr const &amp; pv, std::string const &amp;from);
    std::size_t fromStringArray(
        PVScalarArrayPtr const &amp; pv,
        std::size_t offset, std::size_t length,
        StringArray const &amp; from,
        std::size_t fromOffset);
    std::size_t toStringArray(PVScalarArrayPtr const &amp; pv,
        std::size_t offset,
        std::size_t length,
        StringArray &amp; to,
        std::size_t toOffset);
    int8 toByte(PVScalarPtr const &amp; pv);
    int16 toShort(PVScalarPtr const &amp; pv);
    int32 toInt(PVScalarPtr const &amp; pv);
    int64 toLong(PVScalarPtr const &amp; pv);
    uint8 toUByte(PVScalarPtr const &amp; pv);
    uint16 toUShort(PVScalarPtr const &amp; pv);
    uint32 toUInt(PVScalarPtr const &amp; pv);
    uint64 toULong(PVScalarPtr const &amp; pv);
    float toFloat(PVScalarPtr const &amp; pv);
    double toDouble(PVScalarPtr const &amp; pv);
    std::string toString(PVScalarPtr const &amp; pv);
    void fromByte(PVScalarPtr const &amp; pv,int8 from);
    void fromShort(PVScalarPtr const &amp; pv,int16 from);
    void fromInt(PVScalarPtr const &amp; pv, int32 from);
    void fromLong(PVScalarPtr const &amp; pv, int64 from);
    void fromUByte(PVScalarPtr const &amp; pv,uint8 from);
    void fromUShort(PVScalarPtr const &amp; pv,uint16 from);
    void fromUInt(PVScalarPtr const &amp; pv, uint32 from);
    void fromULong(PVScalarPtr const &amp; pv, uint64 from);
    void fromFloat(PVScalarPtr const &amp; pv, float from);
    void fromDouble(PVScalarPtr const &amp; pv, double from);
}

extern ConvertPtr getConvert();
</pre>

<h4>pvSubArrayCopy.h</h4>
<p>This supports sub-array copying between arrays that have the same type.</p>
<pre>
template&lt;typename T&gt;
void copy(
    PVValueArray&lt;T&gt; &amp; pvFrom,
    size_t fromOffset,
    size_t fromStride,
    PVValueArray&lt;T&gt; &amp; pvTo,
    size_t toOffset,
    size_t toStride,
    size_t count);

void copy(
    PVScalarArray &amp; from,
    size_t fromOffset,
    size_t fromStride,
    PVScalarArray &amp; to,
    size_t toOffset,
    size_t toStride,
    size_t count);

void copy(
    PVStructureArray &amp; from,
    size_t fromOffset,
    size_t fromStride,
    PVStructureArray &amp; to,
    size_t toOffset,
    size_t toStride,
    size_t count);

void copy(
    PVArray &amp; from,
    size_t fromOffset,
    size_t fromStride,
    PVArray &amp; to,
    size_t toOffset,
    size_t toStride,
    size_t count);
</pre>
<p>The last copy is the only one most client need to call.
It either throws an error if the element types do not match or calls the
other copy functions. The arguments are:</p>
<dl>
   <dt>from</dt>
     <dd>The source array.</dd>
   <dt>fromOffset</dt>
      <dd>The offset into the source array.</dd>
   <dt>fromStride</dt>
       <dd>The interval between source elements.</dd>
   <dt>to</dt>
      <dd>The destination array. The element type must be the same
      as for the source array. If the element type is structure then
      the introspection interface for the element types must be the same.
      </dd>
   <dt>toOffset</dt>
      <dd>The offset into the destination array.</dd>
   <dt>toStride</dt>
       <dd>The interval between destination elements.</dd>
   <dt>count</dt>
      <dd>The  number of elements to copy.</dd>
</dl>
<p>An exception is thrown if:</p>
<dl>
   <dt>type mismatch</dt>
     <dd>The element types for the source and destination differ.</dd>
   <dt>immutable</dt>
      <dd>The destination array is immutable.</dd>
   <dt>capacity immutable</dt>
      <dd>The destination array needs to have it's capacity extended
        but the capacity is immutable.</dd>
</dl>
<h4>PVField::copy</h4>
<p>PVField has a method copy.
It allows copying between any two compatible fields.
Both fields must have the same type.
For scalar and scalarArray conversion between the various scalarTypes is supported.
</p>
<p>The following:</p>
<pre>
    PVDataCreatePtr create = getPVDataCreate();
    PVDoublePtr pvDouble = create->createPVScalar&lt;PVDouble&gt;();
    PVBytePtr pvByte = create->createPVScalar&lt;PVByte&gt;();
    pvByte->put(10);
    pvDouble->copy(*pvByte);
    cout &lt;&lt; "double " &lt;&lt; pvDouble &lt;&lt; " byte " &lt;&lt; pvByte &lt;&lt; endl;

    PVStringPtr pvString = create->createPVScalar&lt;PVString&gt;();
    pvString->copy(*pvByte);
    cout &lt;&lt; "string " &lt;&lt; pvString &lt;&lt; " byte " &lt;&lt; pvByte &lt;&lt; endl;
</pre>
produces:
<pre>
double 10 byte 10
string 10 byte 10
</pre>
<p>Likewise for scalarArray:</p>
<pre>
    PVDataCreatePtr create = getPVDataCreate();
    PVDoubleArrayPtr pvDoubleArray = create->createPVScalarArray&lt;PVDoubleArray&gt;();
    PVByteArrayPtr pvByteArray = create->createPVScalarArray&lt;PVByteArray&gt;();
    shared_vector&lt;int8&gt; data(2);
    data[0] = 1; data[1] = 10;
    pvByteArray->replace(freeze(data));
    pvDoubleArray->copy(*pvByteArray);
    cout &lt;&lt; "double " &lt;&lt; pvDoubleArray &lt;&lt; " byte " &lt;&lt; pvByteArray &lt;&lt; endl;

    PVStringArrayPtr pvStringArray = create->createPVScalarArray&lt;PVStringArray&gt;();
    pvStringArray->copy(*pvByteArray);
    cout &lt;&lt; "string " &lt;&lt; pvStringArray &lt;&lt; " byte " &lt;&lt; pvByteArray &lt;&lt; endl;
</pre>
produces:
<pre>
double [1,10] byte [1,10]
string [1,10] byte [1,10]
</pre>
<h2>Special Fields</h2>
<h3>enum</h3>
<p>An enumerated structure is a structure that has fields:</p>
<pre>
enum_t
    int index
    string[] choices
</pre>
<h4>PVEnumerated</h4>
<pre>
PVEnumerated
    boolean attach(PVField pvField)
    void detach()
    boolean isAttached()
    boolean setIndex(int index)
    int getIndex()
    String getChoice()
    boolean choicesMutable()
    String[] getChoices()
    boolean setChoices(String[] choices)
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      pvField (is not, is) an enumerated structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an enumerated structure?</dd>
  <dt>setIndex</dt>
    <dd>Set the index field in the pvData structure. An exception is thrown if
      not attached to a pvData structure. </dd>
  <dt>getIndex</dt>
    <dd>Get the index field in the pvData structure. </dd>
  <dt>getChoice</dt>
    <dd>Get the String value corresponding to the current index field in the
      pvData structure. An exception is thrown if not attached to a pvData
      structure. </dd>
  <dt>choicesMutable</dt>
    <dd>Can the choices be changed? Note that this is often true. An exception
      is thrown if not attached to a pvData structure. </dd>
  <dt>getChoices</dt>
    <dd>Get the array of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>getNumberChoices</dt>
    <dd>Get the number of choices. An exception is thrown if not attached to a
      pvData structure. </dd>
  <dt>setChoices</dt>
    <dd>Change the choices. An exception is thrown if not attached to a pvData
      structure. </dd>
</dl>

<h3>alarm</h3>
<p>An alarm structure is defined as follows:</p>
<pre>
alarm_t alarm
    int severity
    int status
    string message
</pre>
<p>Note that severity and status are NOT defined as enumerated structures.
The reason is performance, i. e. prevent passing the array of choice strings everywhere.
The AlarmStatus and AlarmSeverity provide the equivalent of choices for an
enumerated structure.</p>
<h4>AlarmSeverity</h4>
<p>Alarm Severity defines the possible alarm severities</p>
<pre>
enum AlarmSeverity
    NONE,MINOR,MAJOR,INVALID,UNDEFINED
    AlarmSeverity getSeverity(int value)
    final String[] alarmSeverityNames
    String[] getSeverityNames()
</pre>
where
<dl>
  <dt>getSeverity</dt>
    <dd>Get the alarm severity corresponding to the integer value.</dd>
  <dt>getSeverityNames</dt>
    <dd>Get the array of severity choices.</dd>
</dl>
<h4>AlarmStatus</h4>
<p>Alarm Status defines the possible alarm status conditions</p>
<pre>
enum AlarmStatus
    NONE,DEVICE,DRIVER,RECORD,DB,CONF,UNDEFINED,CLIENT;

    AlarmStatus getStatus(int value)
    String[] alarmStatusNames
    String[] getStatusNames()
</pre>
where
<dl>
  <dt>getStatus</dt>
    <dd>Get the alarm status corresponding to the integer value.</dd>
  <dt>getStatusNames</dt>
    <dd>Get the array of status choices.</dd>
</dl>
<h4>Alarm</h4>
<pre>
Alarm
    String getMessage()
    void setMessage(String message)
    AlarmSeverity getSeverity()
    void setSeverity(AlarmSeverity alarmSeverity)
    AlarmStatus getStatus()
    void setStatus(AlarmStatus alarmStatus)
}</pre>
where
<dl>
  <dt>getMessage</dt>
    <dd>Get the message.</dd>
  <dt>setMessage</dt>
    <dd>Set the message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the severity.</dd>
  <dt>setSeverity</dt>
    <dd>Set the severity.</dd>
  <dt>getStatus</dt>
    <dd>Get the status.</dd>
  <dt>setStatus</dt>
    <dd>Set the status.</dd>
</dl>
<h4>PVAlarm</h4>
<pre>
PVAlarm 
    boolean attach(PVField pvField)
    void detach()
    boolean isAttached()
    void get(Alarm alarm)
    boolean set(Alarm alarm)
</pre>
<p>where</p>
<dl>
  <dt>PVAlarm</dt>
    <dd>The default constructor. Attach must be called before get or set can be
      called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an alarm structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to an Alarm. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Alarm to the pvData structure. An exception is thrown
      if not attached to a pvData structure. </dd>
</dl>


<h3>timeStamp</h3>
<p>A timeStamp is represented by the following structure</p>
<pre>
time_t timeStamp
    long secondsPastEpoch
    int nanoseconds
    int userTag
</pre>

<p>The Epoch is the POSIX epoch, i.e. Jan 1, 1970 00:00:00 UTC. Both the
seconds and nanoseconds are signed integers and thus can be negative. Since the
seconds is kept as a 64 bit integer, it allows for a time much greater than the
present age of the universe. Since the nanoseconds portion is kept as a 32 bit
integer it is subject to overflow if a value that corresponds to a value that
is greater than a little more than 2 seconds of less that about -2 seconds. The
support code always adjust seconds so that the nanoSecconds part is normalized,
i. e. it has is 0&lt;=nanoseconds&lt;nanoSecPerSec..</p>
<h4>TimeStamp</h4>
<p>The definition of TimeStamp is:</p>
<pre>
TimeStamp 
    void normalize()
    long getSecondsPastEpoch()
    long getEpicsSecondsPastEpoch()
    int getNanoseconds()
    int getUserTag()
    void setUserTag(int userTag)
    void put(long secondsPastEpoch,int nanoseconds)
    long getMilliSeconds()
    void put(long milliSeconds)
    void getCurrentTime()
    boolean equals(TimeStamp other)
    boolean lt(TimeStamp other)
    boolean le(TimeStamp other)
    void add(long seconds)
    void add(double seconds)
    double diff(TimeStamp a,TimeStamp b)
}
</pre>
<p>where:</p>
<dl>
  <dt>normalize</dt>
    <dd>Adjust secondsPastEpoch and nanoseconds so that 0&lt;=nanoseconds&lt;nanoSecPerSec.</dd>
  <dt>getSecondsPastEpoch</dt>
    <dd>Get the seconds part of timeStamp</dd>
  <dt>getEpicsSecondsPastEpoch</dt>
    <dd>Get seconds relative to the EPICS epoch. The epics epoch starts on Jan
      1 1990 00:00:00 UTC.</dd>
  <dt>getNanoseconds</dt>
    <dd>Get the nanoseconds part of timeStamp.</dd>
  <dt>getUserTag</dt>
    <dd>Get the userTag</dd>
  <dt>setUserTag</dt>
    <dd>Set the userTag</dd>
  <dt>put(long secondsPastEpoch,int nanoseconds)</dt>
    <dd>Put a value into the timeStamp.</dd>
  <dt>getMilliSeconds</dt>
    <dd>Get the number of milliseconds since the epoch.</dd>
  <dt>put(long milliSeconds);</dt>
    <dd>Put a value into the timeStamp given the number of milliSeconds since
      the epoch.</dd>
  <dt>getCurrentTime</dt>
    <dd>Get the current time.</dd>
  <dt>equals</dt>
    <dd>Is this time equal other?</dd>
  <dt>lt</dt>
    <dd>Is this time less than other.</dd>
  <dt>le</dt>
    <dd>Is this time less that or equal to other.</dd>
  <dt>add(long seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>add(double seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>diff</dt>
    <dd>Compute a-b. The result is in seconds.</dd>
</dl>
<p>The TimeStamp class provides arithmetic and comparison methods for time
stamps. The result is always kept in normalized form, which means that the
nanosecond portion is 0&lt;=nano&lt;nanoSecPerSec. Note that it is OK to have
timeStamps for times previous to the epoch.</p>

<h4>PVTimeStamp</h4>
<pre>
PVTimeStamp 
    boolean attach(PVField pvField)
    void detach()
    boolean isAttached()
    void get(TimeStamp timeStamp)
    boolean set(TimeStamp timeStamp)
</pre>
where
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if a
      timeStamp structure is found. It looks first at pvField itself and if is
      not an appropriate pvData structure but the field name is value it looks
      up the parent structure tree.</dd>
  <dt>detach</dt>
    <dd>Detach from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a timeStamp structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a TimeStamp. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from TimeStamp to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
</dl>

<h3>display</h3>
<p>Display information is represented by the following structure</p>
<pre>
display_t display
    double limitLow
    double limitHigh
    string description
    string format
    string units
</pre>
<h4>Display</h4>
<pre>
Display
    double getLow()
    double getHigh()
    void setLow(double value)
    void setHigh(double value)
    String getDescription()
    void setDescription(String value)
    String getFormat()
    void setFormat(String value)
    String getUnits()
    void setUnits(String value)
</pre>
<p>where</p>
<dl>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>getDescription</dt>
    <dd>Get the description.</dd>
  <dt>setDescription</dt>
    <dd>Set the description.</dd>
  <dt>getFormat</dt>
    <dd>Get the format.</dd>
  <dt>setFormat</dt>
    <dd>Set the format.</dd>
  <dt>getUnits</dt>
    <dd>Get the units.</dd>
  <dt>setUnits</dt>
    <dd>Set the units.</dd>
</dl>

<h4>PVDisplay</h4>
<pre>
PVDisplay
    boolean attach(PVField pvField)
    void detach()
    boolean isAttached()
    void get(Display display)
    boolean set(Display display)
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a display structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a Display. An exception is
      thrown if not attached to a pvData structure.</dd>
  <dt>set</dt>
    <dd>Copies data from Display to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVDisplay instance. Attach must be called before get or set
      can be called.</dd>
</dl>

<h3>control</h3>
<p>Control information is represented by the following structure</p>
<pre>
structure control
    double limitLow
    double limitHigh
    double minStep
</pre>
<h4>Control</h4>
The definition for Control is:
<pre>
Control
    double getLow()
    double getHigh()
    void setLow(double value)
    void setHigh(double value)
</pre>

<p>where</p>
<dl>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
</dl>
<h4>PVControl</h4>
<pre>
PVControl
    boolean attach(PVField pvField)
    void detach()
    boolean isAttached()
    void get(Control control)
    boolean set(Control control)
</pre>
<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>
      Attempts to attach to <span>pvField</span> It returns (false,true) if
      it found an appropriate pvData structure. It looks first a pvField itself
      and if is not an appropriate pvData structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.
     </dd>
  <dt>detach</dt>
    <dd>Just detaches from the pvData structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a control structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the pvData structure to a Control. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Control to the pvData structure. An exception is
      thrown if not attached to a pvData structure. </dd>
  <dt>create</dt>
    <dd>Create a PVControl instance. Attach must be called before get or set
      can be called.</dd>
</dl>

<h3>alarmLimit</h3>
<p>This has unresolved issues.</p>

<h2>Standard for Field::ID</h2>
<p>The introspection interface for every field has an ID, which is available via method:</p>
<pre>
class Field {
...
    string getID();
...
};
</pre>
<p>This section describes how the IDs are assigned.</p>
<h3>Scalar</h3>
<pre>
boolean
byte
short
int
long
ubyte
ushort
ulong
float
double
string
</pre>
<h3>Scalar Array</h3>
<pre>
boolean[]
byte[]
short[]
int[]
long[]
ubyte[]
ushort[]
ulong[]
float[]
double[]
string[]
</pre>
<h3>Union</h3>
<pre>
any        // variant union
union      // restricted union
</pre>
<h3>Union Array</h3>
<pre>
any[]
union[]
</pre>
<h3>structure</h3>
<h4>default</h4>
<pre>
structure
</pre>
<h4>standard fields</h4>
<pre>
alarm_t
time_t
display_t
control_t
enum_t
alarmLimit_t
valueAlarm_t
</pre>
<p><b>Issues:</b></p>
<dl>
   <dt>display_t</dt>
      <dd>This has field
      <pre>string format</pre>
     The allowed syntax should be defined.
      </dd>
    <dt>alarmLimit_t,valueAlarm_t</dt>
      <dd>standardField and standardPVField define
      valueAlarm for boolean, each numeric scalar type, and for enum_t.
     alarmLimit_t has the same fields as valueAlarm for double.
     I suspect that most tools will only use alarmLimit_t.
     What to do?
      </dd>
</dl>
<h3>structure array</h3>
<p>Like structure except that <b>[]</b> is appended.
</p>
<h2>pvRequest and pvCopy</h2>
<p>Both pvDataJava and pvDataCPP provide facilities:</p>
<dl>
   <dt>CreateRequest</dt>
      <dd>
       Creates a PVStructure that is a valid pvRequest
       to be passed between a client a server.
       The Channel class of pvAccess has methods
       that have pvRequest arguments.
       For example:
<pre>
ChannelGet createChannelGet(
    ChannelGetRequester channelGetRequester,
    PVStructure pvRequest);
</pre>
      </dd>
   <dt>PVCopy</dt>
     <dd>
      A client can request an arbitrary subset of the fields
      in the top level PVStructure that server provides.
      PVCopy is a facility that copies data between a top
      level PVStructure that has the clients data and the
      top level PVStructure from the server.
      CreateRequest allows the client to select fields desired.
      PVCopy is used by the server side of pvAccess to 
      transfer data between the two top level PVStructures.
     </dd>
</dl>
<h3>CreateRequest</h3>
<h4>Definition</h4>
<pre>
CreateRequest
    PVStructure createRequest(string request)
    string getMessage()
</pre>
<dl>
   <dt>createRequest</dt>
     <dd>
     Create a pvRequest PVStructure.
     If an invalid request is made a null PVStructure is returned.
     </dd>
    <dt>getMessage</dt>
     <dd>
      The reason why the last request failed.
     </dd>
</dl>
<h4>Purpose</h4>
<p>CreateRequest allows the clients to select an arbitrary subset of the fields in the top level structure
associated with the channel.
It also allows the client to specify options.
Thus the client can specify:</p>
<dl>
  <dt>Global Options</dt>
    <dd>Global options are options that apply to the record itself.</dd>
  <dt>Desired Fields</dt>
     <dd>An arbitrary set of fields can be selected from the top level structure that holds the
      data in the record.</dd>
  <dt>Field Options</dt>
     <dd>These are options that apply to a selected field.
      </dd>
</dl>
<p><b>NOTE:</b> The term record is adapted from pvDatabase. A pvDatabase has a memory resident database of <b>smart</b>
records. A pvAcccess channel is a connection to a record. A record has a top level PVStructure that holds the
data for the record.
A pvAcccess server can be implemented that does not use the pvDatabase model but it must provide top level
PVStructures to which a pvAcccess Channel can be attached.
<b>pvaSrv</b>, which provides access to iocCore V3 records, is an example that also accepts a pvRequest
created by a call to createRequest.
</p>
<h4>Syntax</h4>
<p>A request argument has the syntax:</p>
<pre>
record[option,...]field(fieldDef,...)putField(fieldDef,...)getField(fieldDef,...)
OR
fieldDef,...
</pre>

<p>Thus a request consists of record options and sets of field definitions or
just field definitions. A record option is of the form:</p>
<pre>
record[name=value,...]
</pre>

<p>A field,putFeld,getField is a comma separated set of fieldDefs which are of
the form:</p>
<pre>
fullFieldName
or
fullFieldName[option,...]
or
fullFieldName{fieldDef}     // recursive definition
</pre>

<p>A fullFieldName is the full name of a field in the PVRecord. The name in a
generated data structure will have just the field name. If
<b>fieldName{request}</b> is given then the generated data structure will have
a structure field with subfields. Note that request is a recursive
definition.</p>

<p>If request is null or an empty string than the entire top level structure of the PVRecord is
selected.</p>

<p>The syntax was chosen to be easy to use and to parse:</p>
<dl>
   <dt>record[]</dt>
      <dd>
      Specifies a set of global options, i. e., options that apply to the record itself. 
      </dd>
   <dt>field()</dt>
   <dt>putField()</dt>
   <dt>getField()</dt>
      <dd>
      Each selects a set of subfields of the top level structure.
      Each defines a comma separated set of <b>fieldDef</b>s.
      </dd>
   <dt>fieldDef</dt>
     <dd>Selects a single subfield of the current structure.</dd>
   <dt>option</dt>
      <dd>
      A <b>name=value</b> pair. Both <b>name</b> and <b>value</b> are character strings.
      </dd>
   <dt>[]</dt>
      <dd>
      Holds a comma separated set of <b>option</b>s.
      </dd>
   <dt>{}</dt>
      <dd>
      Selects a set of subfields of a substructure within the top level structure.
      Each defines a comma separated set of <b>fieldDef</b>s.
      This is a recursive definition.
      Thus a <b>fullFieldName</b> within <b>{}</b> is relative to structure that is referenced
      by <b>{}</b>.
      </dd>
</dl>
<h4>Standard Options</h4>
<p>At present the following record options are in use:</p>
<dl>
    <dt>queueSize</dt>
     <dd>
      This is used to define the queueSize for monitors.
      The default is:
<pre>
record[queueSize=2]
</pre>
      A larger size can be specified.
     </dd>
    <dt>process</dt>
     <dd>
      This is used by pvaSrv and pvDatabaseCPP to specify of records should be processed.
      The default is <b>false</b> channelGet and <b>true</b> for channelPut and channelPutGet,
       An example is:
<pre>
record[process=false]
</pre>
     </dd>
    <dt>block</dt>
     <dd>
      This is used by pvaSrv to specify if a request to process a record should
      block until the record completes processing.
      The default is the same as the value ofi the  <b>process</b> option.
      An example is:
<pre>
record[block=false]
</pre>
     </dd>
</dl>
<h4>Simple Examples</h4>
<p>Clients like CSS, Synoptic Displays, Alarm, and Archive only want access to
some combination of the following fields: <b>value</b>, <b>alarm</b>, <b>timeStamp</b>, <b>display</b>, and
<b>control</b>. If the request is for a record that has these all as top level fields
the request string is just a comma separated list of the field names. For
example:</p>
<pre>
"value,alarm,timeStamp"
</pre>

<p>If the record is does not have the desired field at the top level then the
field can still be accessed but in this case the full structure is preserved.
For example:</p>
<pre>
"alarm,timeStamp,power.value"
</pre>

<p>Will get the top level alarm and timeStamp and the value from a
structure named power. Thus the above works for a record that is structured as
follows:</p>
<pre>powerSupply
    alarm
    timeStamp
    power
       value
       display
       ...
    ...
</pre>
What is returned to the client is:
<pre>powerSupply
    alarm
    timeStamp
    power
       value
</pre>

<p>The only option most clients want is to request that a record be processed
as part of a get or put requests. This is done via requests like the
following:</p>
<pre>
"record[process=true]field(value,alarm,timeStamp)"
</pre>
<h4>Power Supply Example</h4>

<p>The following examples are for a power supply record:</p>
<pre>
powerSupply
    alarm
    timeStamp
    power
       value
       alarm
       .. other fields
    voltage
       value
       alarm
       .. other fields
    current
       value
       alarm
       .. other fields
    .. other fields
</pre>


<p>The following request:</p>
<pre>
"field(alarm,timeStamp,power.value)"
</pre>
<p>Will return to the client the following:</p>
<pre>
record psSimple
    alarm_t alarm
        severity NONE status NONE
        message null
    time_t 2013-02-27 06:04:30.997 userTag 0
    structure power
        double value 10.0
</pre>

<p>Note that if the actual record does not have a requested field than it will
not be present in the structure returned to the client.
</p>

<p>The following is the same except that a record option and an option for the
value field will be given.</p>
<pre>
"record[process=true]field(alarm,timeStamp,power.value[monitorAlgorithm=onChange])"
</pre>

<p>The options are to process the record and to cause power.value to cause a monitor only if the value changes.</p>


<p>The following:</p>
<pre>
"field(alarm,timeStamp,power{value,alarm},current{value,alarm},voltage{value,alarm})"
</pre>
<p>Will return to the client the following:</p>
<pre>
record psEmbeded
    alarm_t alarm
        severity NONE status NONE
        message
    time_t 1969-12-31 19:00:00.000 userTag 0
    structure power
        double value 0.0
    structure current
        double value 0.0
        alarm_t alarm
            severity NONE status NONE
            message
    structure voltage
        double value 0.0
        alarm_t alarm
            severity NONE status NONE
            message
</pre>


<h4>Syntax for pvRequest structure created by createRequest</h4>
<p><b>NOTE:</b> This section is only of interest to someone who is implementing code that
has to introspect a structure generated by createRequest.</p>

<p>pvRequest is a PVStructure that describes 1) record options and 2) field
requests and options. It has the following structure:</p>
<pre>
structure
  structure record
    structure _options
      option
      ...
  structure field
    structure fieldName
      structure _options
        option
        ...
      structure fieldName
        structure _options
          option
          ...
        ...
  structure putField
    structure fieldName
      structure _options
        option
        ...
      structure fieldName
        structure _options
          option
          ...
        ...
  structure getField
    structure fieldName
      structure _options
        option
        ...
      structure fieldName
        structure _options
          option
          ...
        ...
</pre>
<p>where</p>
<dl>
  <dt>record</dt>
    <dd>The options that apply to the entire record.</dd>
  <dt>option</dt>
    <dd>This is of the form
      <b>string name value</b>
    </dd>
  <dt>field</dt>
    <dd>Definitions that select fields of the PVRecord and options for the
      fields. This definition is recursive.</dd>
  <dt>fieldName</dt>
    <dd>The field name that will appear in the PVStructure that is a copy of
      the fields selected from the PVRecord. </dd>
</dl>

<p>Note:</p>
<ul>
  <li>The definition is recursive , i.e. an arbitarily complex structure can be
    defined.</li>
  <li>If a pvRequest with no fields is specified than all fields if the target
    PVRecord will appear in the PVCopy.</li>
</ul>

<p>An example of option is process.</p>

<p>Process is a record option:</p>
<pre>
structure
  structure record
    structure _options
      string process true

</pre>
<p>For example if process is an option to createGet then the record will be
processed before data is fetched. NOTE: scalarType boolean is also
supported.</p>

<p>The following is an example of a field option:</p>
<pre>
structure
    structure field
        structure value
            structure _options
                string monitorAlgorithm onChange
</pre>

<p>Some examples are:</p>
<pre>
request
structure

request alarm,timeStamp,power.value
structure
    structure alarm
    structure timeStamp
    structure power
        structure value

request record[process=true]field(alarm,timeStamp,power.value)
structure
    structure record
        structure _options
            string process true
    structure field
        structure alarm
        structure timeStamp
        structure power
            structure value
request record[process=true]field(alarm,timeStamp[algorithm=onChange,causeMonitor=false],power{value,alarm})
structure
    structure record
        structure _options
            string process true
    structure field
        structure alarm
        structure timeStamp
            structure _options
                string algorithm onChange
                string causeMonitor false
        structure power
            structure value
            structure alarm

request record[process=true,xxx=yyy]field(alarm,timeStamp[causeMonitor=true],power.value)
structure
    structure record
        structure _options
            string process true
            string xxx yyy
    structure field
        structure alarm
        structure timeStamp
            structure _options
                string causeMonitor true
        structure power
            structure value
</pre>

<h3>PVCopy</h3>
<p>This is the interface for mapping between a PVStructure that contain a copy
of the data for a subset of the fields in a PVRecord. Note that this interface
is NOT for a single PVStructure but for a single PVRecord and a single
Structure introspection interface that describes a subset of the fields in the
PVRecord. For example if a server supports monitor queues then the server will
allocate a PVStructure for each queue element but will create a single
PVCopy.</p>
<pre>
PVCopy
    PVMaster getPVMaster()
    void traverseMaster(PVCopyTraverseMasterCallback callback)
    Structure getStructure()
    PVStructure createPVStructure()
    int getCopyOffset(PVField masterPVField)
    int getCopyOffset(PVStructure masterPVStructure,PVField masterPVField)
    PVField getMasterPVField(int structureOffset)
    void initCopy(PVStructure pvCopy, BitSet bitSet,boolean masterLocked)
    void updateCopySetBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockMaster)
    void updateCopyFromBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockMaster)
    boolean updateMaster(PVStructure pvCopy,BitSet bitSet,boolean lockMaster)
    PVStructure getOptions(PVStructure copyPVStructure,int fieldOffset)
    String dump()
}
</pre>
<p>where</p>
<dl>
  <dt>getPVMaster</dt>
    <dd>Get the PVMaster to which this PVCopy is attached</dd>
  <dt>traverseMaster</dt>
     <dd>
      Traverse all the fields in master.
      The callback is called for each field in master.
     </dd>
  <dt>getStructure</dt>
    <dd>Get the introspection interface which describes the subset of the
      fields in the PVMaster.</dd>
  <dt>createPVStructure</dt>
    <dd>Create a PVStructure which can hold a subset of the data from the
      PVMaster. A client may require multiple PVStructures. For example if a
      monitor request supports a queue than a PVStructure is required for each
      queue element. </dd>
  <dt>getCopyOffset(PVField masterPVField)</dt>
    <dd>Given a PVField from the master determine the offset within the
      PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt>getCopyOffset(PVStructure masterPVStructure,PVField masterPVField)</dt>
    <dd>Given a masterPVField within a masterPVStructure determine the offset
      within the PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt>getMasterPVField</dt>
    <dd>Given an offset within a PVStructure return the corresponding PVField
      in the PVMaster.</dd>
  <dt>initCopy</dt>
    <dd>Initialize PVStructure with the current data from the PVMaster. The
      bitSet will have offset 0 set to 1 and all other bits set to 0. </dd>
  <dt>updateCopySetBitSet</dt>
    <dd>Update PVStructure from PVMaster. The BitSet shows which fields in
      PVStructure have changed.</dd>
  <dt>updateCopyFromBitSet</dt>
    <dd>Update PVStructure from PVMaster. Only fields that have the offset in
      bitSet set to true are modified.</dd>
  <dt>updateMaster</dt>
    <dd>Update the fields in PVMaster with data from PVStructure. Only fields
      that have the offset in bitSet set to true are modified. </dd>
  <dt>getOptions</dt>
    <dd>Get options for a field in a PVStructure created by pvCopy
    The arguments are the pvStructure and the offset of the field for which the options are wanted.
    It returns the options or null if the field did not have options.
    </dd>
  <dt>dump</dt>
    <dd>Provides a dump of the internal pvCopy nodes. This is useful for debugging
     monitor algorithms.</dd>
</dl>

<h3>Guidelines for pvDatabase Services</h3>
<p>This section is for services that use pvDatabaseCPP.
A service provides a top level PVStructure
and implements methods init, process, and destroy.
pvDatabaseCPP and pvAccessCPP provide a complete implementation of the server
side of pvAccess.
From the PVStructure a PVRecord is created.
This record can be locked.
</p>
<p>pvDatabaseJava is similar except that the service only implements method process.
</p>
<p>A server is providing data for multiple clients.
Each client has it's own top level PVStructure that has data
for a subset of the fields in the servers top level PVStructure.
The service must be careful of how it updates data in it's top leve
PVStructure or else data for a client can change after process completes
and before it is sent to the client.
</p>
<p>Previously the mapping between a PVStructure and it's associated
bitSet as shown:
<a href="#bitAssignment">bitSet for pvStructure</a>
</p>
<p>This can also be used to present guidelines for modifing fields
in the top level PVStructure for the service:</p>
<p>The pvRecord must be locked whenever any field is modfied.</p>
<p>Any union, unionArray, or structureArray field that has a bit
of the bitSet assigned to it <b>must</b> be replaced.
Modifing subFields of the field is <b>not</b> permisible.
</p>

<h2>Appendix I What has been tested</h2>
<h3>exampleJava/database</h3>
<p>The following tests are using the database:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleJava/database/shell
mrk> ./exampleDatabase 
</pre>
<h4>exampleJava/exampleClient</h4>
<table>
   <tr>
      <th>Test</th>
      <th>Result</th>
   </tr>
   <tr>
      <th>examplePvaClientGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMonitor</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMultiDouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientNTMulti</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientProcess</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientPut</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldPutGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldRPC</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
</table>
<h4>exampleCPP/exampleClient</h4>
<table>
   <tr>
      <th>Test</th>
      <th>Result</th>
   </tr>
   <tr>
      <th>examplePvaClientGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMonitor</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMultiDouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientNTMulti</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientProcess</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientPut</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldPutGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldRPC</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>testRAII pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>testRAIIMultiDouble</th>
      <th>Only works with DBRecords</th>
   </tr>
  <tr>
      <th>testRAIINTMulti</th>
      <th>Only works with DBRecords</th>
  </tr>
</table> 


<h3>exampleCPP/database</h3>
<p>The following tests are using the database:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/database/iocBoot/exampleDatabase
mrk> ../../bin/linux-x86_64/exampleDatabase st.cmd 
</pre>
<h4>exampleJava/exampleClient</h4>
<table>
   <tr>
      <th>Test</th>
      <th>Result</th>
   </tr>
   <tr>
      <th>examplePvaClientGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMonitor</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMultiDouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientNTMulti</th>
      <th>many extra 0 elements on array</th>
   </tr>
   <tr>
      <th>examplePvaClientProcess</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientPut</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldPutGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldRPC</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever pva DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever ca DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever pva DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever ca DBRdouble00</th>
      <th>Success</th>
   </tr>
</table>
<h4>exampleCPP/exampleClient</h4>
<table>
   <tr>
      <th>Test</th>
      <th>Result</th>
   </tr>
   <tr>
      <th>examplePvaClientGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMonitor</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientMultiDouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientNTMulti</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientProcess</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>examplePvaClientPut</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldPutGet</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>helloWorldRPC</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever pva DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>getForever ca DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever pva DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>monitorForever ca DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>testRAII pva PVRdouble</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>testRAII pva DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>testRAII ca DBRdouble00</th>
      <th>Success</th>
   </tr>
   <tr>
      <th>testRAIIMultiDouble pva</th>
      <th>Success</th>
   </tr>
  <tr>
      <th>testRAIIMultiDouble ca</th>
      <th>Success</th>
   </tr>
  <tr>
      <th>testRAIINTMulti pva</th>
      <th>Success</th>
  </tr>
  <tr>
      <th>testRAIINTMulti ca</th>
      <th>Success</th>
  </tr>
</table> 
<h3>exampleJava/exampleLink</h3>
<p>Starting either:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleJava/exampleLink
mrk> scripts/exampleLinkMain pva doubleArray true
</pre>
or
<pre>
mrk> pwd
/home/epicsv4/master/exampleJava/exampleLink
mrk> scripts/exampleLinkMain local doubleArray true
</pre>
<p>exampleLinkClient works in both exampleJava and exampleCPP.</p>
<p>Starting both</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleJava/exampleLink
mrk> scripts/doubleArrayMain
</pre>
and 
<pre>
mrk> pwd
/home/epicsv4/master/exampleJava/exampleLink
mrk> scripts/exampleLinkMain pva doubleArray true
</pre>
<p>exampleLinkClient works in both exampleJava and exampleCPP.</p>
<h3>exampleCPP/exampleLink</h3>
<h4>Success</h4>
<p>Starting either:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleLink/iocBoot/exampleLink
mrk> ../../bin/linux-x86_64/exampleLink st.cmd 
</pre>
or
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleLink/iocBoot/exampleLink
mrk> ../../bin/linux-x86_64/exampleLink st.local
</pre>
<p>exampleLinkClient works in both exampleJava and exampleCPP.</p>
<p>Starting:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleLink/iocBoot/doubleArrayExternal
mrk> ../../bin/linux-x86_64/exampleLink st.cmd
</pre>
and either
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleLink/iocBoot/exampleLink
mrk> ../../bin/linux-x86_64/exampleLink st.extca
</pre>
or
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleLink/iocBoot/exampleLink
mrk> ../../bin/linux-x86_64/exampleLink st.extpva
</pre>    
<p>exampleLinkClient works in both exampleJava and exampleCPP.
</p>
<p>
But exampleLinkClient must be run with the arguments "pva doubleArrayExternal"
</p>

<h3>exampleJava/helloPutGet and exampleCPP/helloPutGet</h3>
<p>The following servers were tested:</p>
<ol>
    <li>Java implementation of helloPutGetMain</li>
    <li>C++ implementation of helloPutGetMain</li>
    <li>helloPutGet as part of a V3 IOC</li>
</ol>
<p>For each server both the Java and C++ versions of helloPutGetClient were tested</p>
<p>All tests were successfull.</p>
<h3>exampleJava/helloRPC and exampleCPP/helloRPC</h3>
<p>The following servers were tested:</p>
<ol>
    <li>Java implementation of helloService</li>
    <li>C++ implementation of HelloService</li>
</ol>
<p>For each server both the Java and C++ versions of helloClient were tested</p>
<p>All tests were successfull.</p>
<p><b>But</b> neither server terminated wnen exit was issued.</p>

<h3>exampleJava/powerSupply and exampleCPP/powerSupply</h3>
<p>The following servers were tested:</p>
<ol>
    <li>Java implementation of powerSupplyMain</li>
    <li>C++ implementation of powerSupplyMain</li>
    <li>powerSupply as part of a V3 IOC</li>
</ol>
<p>For each server both the Java and C++ versions of powerSupplyMonitore were tested.
After both were started then the following was run:</p>
<pre>
pvput -r "power.value,voltage.value" powerSupply 1 2
</pre>
This test was successful.
<p>However when powerSupplyClient was run a failure occurs.
See the next section for details.
</p>

<h3>exampleJava/pvDatabaseRPC and exampleCPP/pvDatabaseRPC</h3>
<p>The following servers were tested:</p>
<ol>
    <li>Java implementation of exampleRPCMain</li>
    <li>C++ implementation of exampleRPCMain</li>
    <li>exampleRPC as part of a V3 IOC</li>
</ol>
<p>The following was started to see the result of run requests:</p>
<pre>
pvget -m mydevice
</pre>
<p>Next the following commands were issued on both Java and C++:</p>
<pre>
control configure 1 1
control run
</pre>
<p>All tests were successful.</p>

<h3>exampleJava/serviceAPI</h3>
<p>The server was started and then the client.</p>
<p>The test was successful but the server does not accept an exit command.</p>
<h2>Appendix II Known Problems</h2>
<h3>pvDataJava</h3>
<dl>
    <dt>Field</dt>
      <dd>Does not implement getNumberFields</dd>
    <dt>PVDataCreate</dt>
       <dd>Why does the following method exist?
<pre>
PVStructure createPVStructure(string[] fieldNames,PVField[] pvFields)
</pre>
        </dd>
</dl>
<h3>pvaClient</h3>
<dl>
    <dt>getField</dt>
       <dd>Not implemented</dd>
    <dt>channelArray</dt>
       <dd>Not implemented</dd>
</dl>
<h3>C++ Server Segmentation Fault on exit</h3>
<p>Sometimes a segmantation fault occurs when a C++ server terminates.</p>
<h3>exampleCPP/ChannelArchiverService</h3>
<p>Needs documentation.</p>
<h3>exampleJava</h3>
<h4>exampleClient</h4>
<dl>
   <dt>helloRPC</dt>
      <dd>helloWorldRPC does not terminate.</dd>
   <dt>provider ca</dt>
      <dd>numeric arrays are filled out with 0s</dd>
</dl>

<h4>helloRPC</h4>
<ul>
   <li>This is left almost unchanged since release 4.5</li>
   <li>helloService does not terminate.</li>
   <li>The CPP version allows a client to issueConnect and waitConnect.
      The Java version does not support this.
   </li>
</ul>

<h4>powerSupply</h4>
<p>
The powerSupplyClient ends with setting voltage to 0.
This causes the PVRecord to throw an exception, which pvAccess passes back to the client.
All appears OK except that if another client has a monitor on the PVRecord,
that client no longer gets an monitor updates.
</p>
<h4>rdbService and serviceAPI</h4>
<p>
These are left almost unchanged since release 4.5.
</p>
<p>
<b>Greg:</b> Please look at these examples and decide what should be done.
</p>

<h3>exampleCPP</h3>
<h4>monitors</h4>
<p>
When a monitor is issued to a channel that is served by dbPv (pvaSrv),
Each monitor shows that all requested fields have changed.
</p>
<h4>helloRPC</h4>
<p>
helloService does not terminate.
</p>
<h4>exampleLink</h4>
<dl>
    <dt>st.ca</dt>
      <dd>
         Starting:
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/exampleLink/iocBoot/exampleLink
mrk> ../../bin/linux-x86_64/exampleLink st.ca
</pre>
           Does not work.<br />
           When started this way the LinkRecord sets a monitor via provider "ca",
            which means that
            pvAccess sets a monitor via provider ca on a V3 record that is in the same IOC.
            The linkRecord never receives monitors.
      </dd>
      <dt>Using provider dbPv</dt>
         <dd>Attempting to use provider dbPv, i.e. pvaSrv, does not work.</dd>
</dl>
<h4>powerSupply</h4>
<p>
The powerSupplyClient ends with setting voltage to 0.
This causes the PVRecord to throw an exception, which pvAccess passes back to the client.
All appears OK except that if another client has a monitor on the PVRecord,
that client no longer gets an monitor updates.
</p>
<h4>memory leaks</h4>
<p>
When any of the examples terminate valgrind shows memory leaks.
Clients not so bad but servers not so good.
</p>
<h3>epicsbase: 3_14 vs 3_15</h3>
<p>
The following is from the exampleLink in https://github.com/mrkraimer/exampleCPP.
</p>
<p>
I also added some print statement in pvAccessCPP/src/server/responseHandlers.cpp 
</p>
<p>
The example is started as part of an IOC with two channel providers started: dbPv and local.
</p>
<p>
Then I did a:</p>
<pre> pvget exampleLink
</pre>
<p>
Note that the provider for exampleLink is local. 
</p>
<p>
With base 3.14 I get</p>
<pre>
epics> ServerChannelFindRequesterImpl::channelFindResult _responseCount 0 _expectedResponseCount 2 wasFound 0
ServerChannelFindRequesterImpl::channelFindResult _responseCount 1 _expectedResponseCount 2 wasFound 1
ServerChannelRequesterImpl::channelCreated status 1 channel exampleLink
epics> ServerChannelFindRequesterImpl::channelFindResult _responseCount 0 _expectedResponseCount 2 wasFound 0
ServerChannelFindRequesterImpl::channelFindResult _responseCount 1 _expectedResponseCount 2 wasFound 1
ServerChannelRequesterImpl::channelCreated status 1 channel exampleLink
</pre>
<p>
With base 3.15 I get</p>
<pre>
epics> ServerChannelFindRequesterImpl::channelFindResult _responseCount 0 _expectedResponseCount 2 wasFound 0
ServerChannelFindRequesterImpl::channelFindResult _responseCount 1 _expectedResponseCount 2 wasFound 1
ServerChannelRequesterImpl::channelCreated status 0
</pre>
<p>
NOTE that it never tried the second provider, i. e. provider local.
Instead something tried to create channel from provider dbPv.
</p>
<p>
I did some more looking and it does not appear that pvaSrv is the problem.
It looked like something in base3.15 src/ioc/db/dbChannel.c was calling dbChannelCreate as a result of calling dbChannelTest.
But I never got to the final problem.
</p>
<p>
Also I created a example application for both 3.14 and for 3.15.
Running the example ioc via valgrind shows some memory problems under both 3.14 and 3.15.
BUT 3.15 has LOT more problems.
</p>
<p>
I saw the same thing when I ran exampleCPP/exampleLink/iocBoot/exampleLink.
</p>

</div>
</body>
</html>
