<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="keywords" content="EPICS, EPICSv4" />

<!-- Include the epicsv4 base.css, and the css for epics v4 documents -->
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="epicsv4.css" />

<title>Getting Started with EPICS V4</title>

<style type="text/css">
/*<![CDATA[*/
h2 { page-break-before : always; }
/*]]>*/

</style>
<!-- Script that generates the Table of Contents -->
  <script type="text/javascript" src="http://epics-pvdata.sourceforge.net/script/tocgen.js"></script>
</head>

<div class="head">
<h1>GETTING STARTED WITH EPICS V4</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->
<h2 class="nocount" >
  Getting Started with EPICS V4, Editors draft</h2>
<p><b>NOTE: This page has not been updated since 2015.
   It needs work.</b>
  </p>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://epics-pvdata.sourceforge.net/gettingStarted_20151017.html">
gettingStarted_20151017.html</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://epics-pvdata.sourceforge.net/gettingStarted.html">gettingStarted.html</a></dd>
<dt>Previous version:</dt>
<dd><a href=
"http://epics-pvdata.sourceforge.net/gettingStarted_20150805.html">
gettingStarted_20150805.html</a></dd>
<dt>Editors:</dt>
<dd>Greg White, SLAC<br>
    Dave Hickin, Diamond<br>
    Timo Korhonen, ESS<br>
    Ralph Lange, ITER</dd>
</dl>
<hr />
</div> <!-- Header material -->

<h2 class="nocount" id="abstract">Abstract</h2>

<p>This document describes how to download and build the EPICS V4
toolkit. It is a step by step guide to downloading the appropriate EPICS V4 products
and associated software, and to using them to create the example programs. Presently, the
document concentrates on interfacing to EPICS Base IOC control data, through the C++ bindings of new EPICS V4
modules pvAccess and pvData, and on developing middleware EPICS data services using
the RPC capability of pvAccess in Java and C++.
</p>

<h2 class="nocount" id="status">Status of this Document</h2>

<p>This is version 20151017 of the Getting Started document. This version has been updated with respect to EPICS V4.5.</p>

<p>A more complete <a href="informative/developerGuide/developerGuide.html" >developers guide is in preparation</a>.</p>


<div id="toc">
  <h2 class="nocount">Table of Contents</h2>
</div>


<!-- Place what you would like in the Table of Contents, inside the contents div -->

<div id="contents" class="contents">  
<hr />
<h2>Introduction</h2>

<p>EPICS V4 is implemented in C++ and Java. Its APIs are in C++ and Java mainly,
though wrappers are being produced for Python and Matlab. However, this document
covers only development in Java and C++.</p>
  
  <p><strong>Please note that while we make effort to keep this document up to date, we don't regenerate all examples and graphics to be consistent with every release number etc. Please offer us some latitude in keeping this document perfect.</strong></p>


<h3>The Core Modules that Comprise EPICS V4</h3>

<p>Release "EPICS V4.5" is comprised of 2 "core" modules: pvData, and
pvAccess. These are the minimum required to create V4 clients and services.</p>

<p>In addition there are a number of higher-level modules: pvDatabase and pvaClient make 
it easier to create services and clients respectively; pvaSrv adds pvAccess services to V3 IOCs; 
normativeTypes implements certain standard pvData types (the Normative Types). You don't <i>need</i> to use these higher-level. For example you can create V4 applications that don't use the normativeTypes module - either because they don't use Normative Types or because the latter are implemented without using the module. Similarly you can create clients without pvaClient and services without pvDatabase or pvaSrv (and there is an RPC framework in pvAccess to implement RPC services and clients). However using these higher-level modules make it much easier to build many applications.
</p>

<p>The specifications for the function of these are (or are
presently being) defined
as <a href="http://epics-pvdata.sourceforge.net/epicsv4process.html#normative" >normative
documents</a> of the EPICS V4 working group, and available from the
homepage <a href="http://epics-pvdata.sourceforge.net/index.html"> the EPICS V4
homepage</a>. There are Java and C++ implementations of each of the core modules. The source
code of each can be acquired from Git. To use them, you can download and build
them from the source, from Git or from a release bundle tar file, as described below.
For Java, the release bundle tar file includes prebuilt Jars. This document deals with 
acquiring, building, and first steps in using the core modules, plus pvaSrv to connect to 
EPICS Base IOCs.

However, there are many more pieces of software in the EPICS V4 "ecosphere", please
see the homepage, and
the <a href="https://github.com/epics-base/">EPICS V4
Git web site</a>.</p>

<p>The following is a summary of the modules of EPICS V4.5.
<pre>
C++ Module Summary:

pvDataCPP           The EPICS V4 data types.
pvAccessCPP         The EPICS V4 "wire protocol". Supports pvData.
normativeTypesCPP   Support for EPICS V4 Normative Types.
pvaSrv              pvAccess interface to EPICS Base IOC databases.
pvDatabaseCPP       EPICS V4 record/database framework for providing services over pvAccess.
pvaClientJava       A higher-level API for writing pvAccess clients.
pvaPy               Python API for pvAccess.
exampleCPP          Code examples, including use of pvData containers, RPC, demo servers.
pvCommonCPP         Utility libraries.

Java Module Summary: 

pvDataJava          The EPICS V4 data types.
pvAccessJava        The EPICS V4 "wire protocol". Supports pvData.
normativeTypesJava  Support for EPICS V4 Normative Types.
pvDatabaseJava      EPICS V4 record/database framework for providing services over pvAccess.
pvaClientJava       A higher-level API for writing pvAccess clients.
easyPVAJava         (Deprecated) Older version of pvaClientJava. 
exampleJava         Code examples, including use of pvData containers, RPC, demo servers. 
directoryService    EPICS V4 interface to classic EPICS directoryService.
caj                 An all Java implementation of the Channel Access protocol.
jca                 A Java API and wrapper interface to the C++ implementation of
                    the Channel Access protocol.
</pre>
<p>The versions of each module are formally listed in
<a href="https://github.com/epics-base/pvDataWWW/blob/master/scripts/RELEASE_VERSIONS">RELEASE_VERSIONS</a>.</p>  

<p>The dependency hierarchy between the above is the following:

<ul>
<li>pvData is independent</li>
<li>pvAccess and normativeTypes both depend only on pvData</li>
<li>The examples and pvaSrv depends on pvData and pvAccess</li>
<li>pvaClient and pvaPy depend on pvData, pvAccess and normativeTypes</li>
<li>pvDatabaseCPP depends on pvDataCPP, pvAccessCPP and (for example code) pvaSrv</li>
<li>pvDatabaseJava depends on pvDataJava, pvAccessJava and pvaClientJava</li>
</ul>

<p>In addition for C++ there is the utility module pvCommonCPP. This contains boost, needed in particular for shared_pointers, and a microbenchmark framework. If you don't intend to use the latter then you may not need pvCommonCPP, depending on your compilers support for shared_pointers.<p>

<p>When building the modules these interdependencies must be taken into account.</p>

<h3>Interoperation with EPICS Base (aka V3)</h3>

<p>To link the new EPICS V4 modules to EPICS Base IOC records, two basic approaches are possible.</p>

<p>In the first, an embedded pvAccess server inside a Base IOC (say running EPICS
V3.14/15) accesses records directly
through the database, allowing a V4 client to communicate with the "V3" records through pvAccess.
This is provided by <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvaSrv/tip/documentation/pvaSrv.html"
>pvaSrv</a> and implemented in C++.</p>
<p>Alternatively EPICS V4 can link to the Base IOC records using Channel Access. Starting with the past release 
 V4.3, this may be done in both Java and C++ implementations of pvAccess, though
for Java, jca*.jar and caj*.jar, are prerequisites. There are two modes of such interoperation. Firstly, an embedded Channel Access client inside a 
pvAccess server allows it to communicate with an EPICS Base IOC. Secondly, the pvAccess server (part of pvAccess above) allows an existing
EPICS Base Channel Access client to access a pvIOC database. These interoperability
functions require JCA and CAJ <a class="bib" href="#bib:jca">jcaandcaj</a>. These are
available from the EPICS V4 download
site <a href="http://sourceforge.net/projects/epics-pvdata/files/">
http://sourceforge.net/projects/epics-pvdata/files/</a> or from their reference
sources.</p>

<h3>Version Compatibility</h3>

<p>When we say "EPICS Base", or loosely "V3", in general we mean EPICS Base version 3.14.12 (preferably 3.14.12.4 or later) or 3.15.x.</p>

<p>Prior to 4.5.0, the implementation of pvaSrv did not reflect API changes
made in Base 3.15.1. As a result, using pvaSrv required 3.14.12.x. As of 4.5.0
pvaSrv has been updated to build against 3.15.1.</p>

<p><strong>As of EPICS V4.4.0, pvAccessJava requires at least Java 1.7. </strong></p>



  <h3>Where to find more information</h3>
  <p>The programmers reference documentation for each software component of EPICS V4 is listed in the 
<a href="http://epics-pvdata.sourceforge.net/literature.html" >Literature</a> page.

The pvAccess protocol is described in its <a href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html" >specification</a>.

Environment settings, <kbd>EPICS_PVA_ADDR_LIST</kbd> etc, are described in the <a href="http://epics-pvdata.sourceforge.net/pvAccessConfig.xlsx" >pvAccess Configuration spreadsheet (Excel)</a>.

Check CPU architecture compatibility in the <a href="http://epics-pvdata.sourceforge.net/Ev4buildtracker.xls" >Compatibility Tracker (Excel)</a>.</p>

<p>If you get into trouble, you might first check the <a href="troubleshooting.html">Troubleshooting EPICS V4</a>
cheatsheet, which lists very first steps in finding and resolving problems with EPICS
V4 connections.

After that, email <a href="http://www.aps.anl.gov/epics/tech-talk/" >EPICS tech-talk</a> or contact the <a href="http://epics-pvdata.sourceforge.net/home.html" >EPICS V4 working group</a>.</p>

<h3>Java and C++ development</h3>

<p>Since the development cycle (compile, build, etc.) is significantly
different for each language, and to match suitable language API description to
suitable use cases, this guide is split into 2 major parts. Firstly, Java
development and secondly C++ development.
</p>
 
<h2>Java Development</h2>

<p>This section is on software development, with and of, the Java implementation of
EPICS V4. For C++ development, see below. </p>

<p>V4.4+ Java requires Java 1.7</p>

<p>The Java implementation of the EPICS V4 modules, is made available in two
ways. Firstly, you can download EPICS V4 as a tarball of the jar files directly from
the EPICS V4 SourceForge site. Alternatively, you can download the Java sources from
their Git repos and build it yourself.</p>

<p>You would use the tar file mechanism of acquiring EPICS V4 if you only intend to
use EPICS V4's Java implementation as a user. If you want to contribute to
development at all, or to examine the source for other reasons, you probably want to
acquire EPICS V4 by the method of downloading the Git source, and building with
Maven.  Each of these will be described below.</p>


<p>Since the minimum EPICS V4 runtime is composed of the 2 modules pvData and pvAccess,
you will need at least those two. The sections below will guide you through
<a href="#getjars"> acquiring them from Jars</a> or
<a href="#sourcedownload">building from the source</a>.</p>

<p>If you intend to use EPICS V4's Java client side to talk Channel Access to EPICS Base
IOCs, then you will additionally need caj and jca. Those two are bundled in the
Java tar file.</p>

<h3 id="getjars">Getting EPICS V4 Java Implementation from the tar of the Jar Files</h3>

<p>The simplest way to acquire EPICS V4's Java implementation is to download the tar
file of the jars, from the EPICS V4 SourceForge download
site, <a
href="http://sourceforge.net/projects/epics-pvdata/files/">http://sourceforge.net/projects/epics-pvdata/files/</a>
<a href="#downloadsite">[downloadsite]</a>. See in particular the README file at the
site..</p>

<p>The table above lists the modules that comprise the Java implementation of the
EPICS V4 suite. The 2 modules named pvAccess*.jar
and pvData*.jar make up the core of EPICS V4  The tar file
contains these and others. You'll need at least
what's in the tar.gz. </p>

<!-- img src="image/sfdownloadfiles4_3.png" width="638" height="198" -->

<p>To get off the ground using Java download, see the examples in the
epics-pvdata <a href="https://github.com/epics-base/exampleJava/tree/master/src/" >exampleJava Git repo</a> [<a href="#ev4examples-java" ></a>ev4examples-java]. <em>The setup files of those examples
(<a href="https://github.com/epics-base/exampleJava/tree/master/src/services/helloWorld/helloWorld_setup.bash" >helloWorld_setup.bash</a> and <a href="https://github.com/epics-base/exampleJava/tree/master/src/services/rdbService/rdb_setup.bash" >rdb_setup.bash</a>) are written assuming
local .class files, you'll have to convert them so the CLASSPATH points to the
jar files instead - <a href="#step-by-step">as described below</a> ).</em> So far only 
examples of the "ChannelRPC" functionality of EPICS V4 are 
included in the exampleJava repo, since it's assumed Java would mainly be used for host side services, but more will be added.</p>

<h4 id="step-by-step">Step by step</h4>
<p>This section is a guide for acquiring and configuring the files in the Java
tar.gz. For illustration we test successful execution of the helloWorld client/server example.
<ol>
<li>Download the tar.gz from SourceForge <a
href="http://sourceforge.net/projects/epics-pvdata/files/">http://sourceforge.net/projects/epics-pvdata/files/</a></li>

<li>Untar it,
<pre>
% tar xvfz EPICS-Java-4.4.0.tar.gz  [if you got it compressed]
% tar xvf EPICS-Java-4.4.0.tar      [if you got it uncompressed]
</pre>
You should see about 30 jar files, of executable, source and javadoc (exact version numbers may have changed by the time you read this):
<pre>
% ls  EPICS-Java-4.5.0
caj-1.1.15.jar                      LICENSE.txt
caj-1.1.15-javadoc.jar              normativeTypesJava-0.1.2.jar
caj-1.1.15-sources.jar              normativeTypesJava-0.1.2-javadoc.jar
directoryService-0.4.2.jar          normativeTypesJava-0.1.2-sources.jar
directoryService-0.4.2-javadoc.jar  pvAccessJava-4.1.2.jar
directoryService-0.4.2-sources.jar  pvAccessJava-4.1.2-javadoc.jar
easyPVAJava-4.1.2.jar               pvAccessJava-4.1.2-sources.jar
easyPVAJava-4.1.2-javadoc.jar       pvaClientJava-4.1.3.jar
easyPVAJava-4.1.2-sources.jar       pvaClientJava-4.1.3-javadoc.jar
exampleJava-4.0.5.jar               pvaClientJava-4.1.3-sources.jar
exampleJava-4.0.5-javadoc.jar       pvDatabaseJava-4.1.2.jar
exampleJava-4.0.5-sources.jar       pvDatabaseJava-4.1.2-javadoc.jar
jca-2.3.6.jar                       pvDatabaseJava-4.1.2-sources.jar
jca-2.3.6-javadoc.jar               pvDataJava-5.0.2.jar
jca-2.3.6-sources.jar               pvDataJava-5.0.2-javadoc.jar
lib                                 pvDataJava-5.0.2-sources.jar
</pre>
</li>

<li>To play with exampleJava, you'll need to edit setup files. So create an exampleJava
subdirectory and extract exampleJava
from its sources jar file into it: 
<pre>
% mkdir exampleJava
% cd exampleJava
% jar xf ../EPICS-Java-4.5.0/exampleJava-4.0.5-sources.jar
% ls -l
total 8
0 drwxrwxr-x. 3 greg  staff 4096 Oct 16 20:28 illustrations
0 drwxrwxr-x. 2 greg  staff 4096 Oct 16 20:28 META-INF
0 -rw-rw-r--. 1 greg  staff 1211 Oct 16 20:28 overview.html
0 drwxrwxr-x. 4 greg  staff 4096 Oct 16 20:28 services
</pre>
</li>


<li>Try out helloWorld RPC service.

<p>The simplest example of an EPICS V4 pvAccess server that provides functions new in V4,
is the helloWorld in exampleJava. It shows a pvAccess server taking a argument, and returning
a string based on the argument.</p>

<p>Modify helloWorld_setup.bash.</p>

<p> The helloWorld example is in <code>exampleJava/services/helloWorld/</code>.
Note that exactly how the setup must be, will depend
on whether you intend to execute the example code from its jar, as download in the
distribution tar, or to extract the source of the example so you can look at it and
build it, or whether thirdly you may have cloned the repos. This example will assume
you want to extract the source of the exampleJava, and compile that, and execute it
using the support in the jar files of the EPICS V4 core. <strong>Again note, version ids may be different</strong>.</p>

<ol>

  <li>Set the root dir of the EPICS V4 stuff (i.e., the directory created by the untar):
    <pre>
WORKSPACE=$HOME/Temporary/EPICS-Java-4.5.0
</pre>
  </li>

  <li>Set the location of the examples (i.e., the directory created by the unjarring the example source jar):
    <pre>
EXAMPLES=$HOME/Temporary/exampleJava
</pre>
  </li>


  <li>Edit CLASSPATH to point to where your examples code class files are, or will
  be; and to point to the downloaded jars:
  <pre>
CLASSPATH=${EXAMPLES}
CLASSPATH=${CLASSPATH}:${WORKSPACE}/pvDataJava-5.0.2.jar
CLASSPATH=${CLASSPATH}:${WORKSPACE}/pvAccessJava-4.1.2.jar</pre>
  </li>

<li>Compile examples. This can be done simply with javac (after you've used
helloWorld_setup.bash to set the CLASSPATH):
<pre>
cd to exampleJava/services/helloWorld, then
$ source helloWorld_setup.bash
$ javac *.java
</pre>
</li>

<li>Start the server (you'll see quite a bit of output. Check there are no complaints
of file-not-found). First, just once, you'll need to chmod +x the runner scripts:

<pre>
$ chmod +x helloServerRunner helloClientRunner 
% ./helloServerRunner
</pre>

<em>Tip: If you get a ClassNotFound, you can diagnose your runtime environment's CLASSPATH by sourcing helloWorld_setup.bash, and then running a command like <code>printenv CLASSPATH | tr : '\n' | xargs -I{} ls {}</code></em>

</li>

<li>In another process, or even another network node, run the client, giving an argument. The client will find the server process, send the argument, receive a greeting for that argument, and print it:

<pre>
% ./helloClientRunner Stefania
Hello Stefania
</pre>
</li>
</ol>




</ol>
<h3 id="sourcedownload">Getting EPICS V4 Java Implementation Source and Building using Git and Maven</h3>

<p>The use case of downloading the source using Git (aka "git"), and building
with Maven, would be applicable if you are a Java developer and wish either to
contribute to EPICS V4, or like to use a command line for your Java builds, or
both. </p>

<p>The EPICS V4 software components (pvData, pvAccess) are each in
distinct Git repositories in the SourceForge project epics-pvdata. There are
separate Git repos for each of the C++ and Java implementations of each
component [<a href="#EPICSV4repos" >EPICSV4repos</a>]. They can all be
checked out via the Git unix shell command git, or using a Git GUI client
suitable for your platform.</p>

<p>The procedure defined below will help you download the source for the pv core modules
above, plus the caj/jca jars, and build pv core jars.</p>

<h4 id="prerequisites">Prerequisites</h4>

<p>V4.4+ Java requires Java 1.7</p>

<p>Clone from the Git repositories can be done anonymously. Below is an example of how to check
out the pvDataJava Git repository, using the git unix command via anonymous
access:</p>

<pre>% git clone https://github.com/epics-base/pvDataJava.git
</pre>

<h4 id="createlocalrepo">Create your local Git "repo" for your EPICS V4 work</h4>

<p>Having installed Git, now download the source. You'll create a local Git
"repository" <strong>for each</strong> EPICS V4 module you get.</p>

<p>First, you may want to create a root directory in which to house your repo directories, e.g.:</p>

<pre>
% pwd
/Users/greg/Development/epicsV4/
% mkdir git
% cd git
</pre>

<h4 id="javadownload">Download minimum EPICSv4 Java implementation repos from epics-pvdata into local repos</h4>

<p>To download the source using Git, use an "git clone" command, executed while in the
directory you created, i.e. "git/" in the example above.

You will need at least the 2 core "normative" module Java
implementations pvDataJava and pvAccessJava (the first 2 below).

You may well also want:
<ul>
<li>exampleJava: example servers and clients</li>
<li>normativeTypesJava: support for EPICS V4 Normative Types</li>
<li>pvaClientJava: beta-level development of a simple client side API for pvAccess</li>
<li>pvDatabaseJava: EPICS V4 record/database framework for providing services over pvAccess.
</li>
</ul>

See RELEASE_VERSIONS <a class="bib" href="#bib:relver">relver</a> for the other 
modules bundled with the release, that you may also want to clone.</p>

<pre>
[from git/ directory in this example, created above]
% git clone https://github.com/epics-base/pvDataJava.git
% git clone https://github.com/epics-base/pvAccessJava.git
% git clone https://github.com/epics-base/exampleJava.git
% git clone https://github.com/epics-base/normativeTypesJava.git
...
</pre>
<p>See the complete list in the file which formally lists all of the components in each EPICS V4 release, <a href="https://github.com/epics-base/pvDataWWW/blob/master/scripts/RELEASE_VERSIONS" >RELEASE_VERSIONS</a></p>

<h4 id="javabuild">EPICS V4 Java Implementation Build</h4>

<p>The build dependencies of the EPICS v4 modules are:</p>

<ul>
<li>pvData is independent</li>
<li>pvAccess and normativeTypes both depend only on pvData</li>
<li>exampleJava depends on pvData, pvAccess</li>
<li>pvaClientJava depends on pvDataJava, pvAccessJava and normativeTypesJava</li>
<li>pvDatabaseJava depends on pvDataJava, pvAccessJava and pvaClientJava</li>
</ul>

<p>When building (instructions below) you will see warnings, but should not see any
errors if the build is successful. Warnings come from both source compiles and many
from javadoc compiles. At the end of each "mvn compile install" process, you should
see:</p>

<pre>
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
</pre>

<p>The build itself is handled by Maven for Java builds. The actions for the build of
each EPICS V4 module is handled by its own pom.xml file, there is no global one. So,
the build process involves "cd" ing to the cloned repository (as they're called in
Git speak) of each one of the core modules, and issuing "mvn compile install"
in each one. Start with pvDataJava since it has no dependencies, then pvAccessJava,
then the others.
</p>

<p>If this is really the first Maven build you've done, the first mvn compile line
below will result in 2 things: First, it will create your local "m2 repo" (in ~/.m2
by default). Then it will initiate <strong>many</strong> downloads from sourceForge and Maven as well as prerequisites of Maven. But if you chose this path to EPICS v4,
you probably knew that! 
</p>

<pre>
% pwd
/Users/greg/Development/epicsV4/git             [in this example]

% cd pvDataJava/
% mvn compile install

% cd ../pvAccessJava/
% mvn compile install -Dmaven.test.skip=true
</pre>

<p> Note that as written here, the <kbd>mvn compile install</kbd> commands skip the
post compilation tests. <i>These tests would include exception handling tests, the
output of which look like errors, because the tests are specifically to test for
correctly dealing with runtime errors.</i> If you you would like to include the
tests, remove the Maven option <kbd>-Dmaven.test.skip=true</kbd>.  </p>


<p>The above 2 complete the build of the EPICS v4 core. You may also want to try the
examples which are in the exampleJava module, and a somewhat simplified pvAccess API
named easyPVA. exampleJava uses easyPVAJava, so get them both and build it with the
following:</p>

<pre>
% cd ../easyPVAJava/
% mvn compile install -Dmaven.test.skip=true

% cd ../examplesJava
% mvn compile install
</pre>

<p>The outcome of these builds is that you should see all of the build products
in your local Maven repository (<kbd>~/.m2/repository/</kbd> by default).</p>

<p>The minimum EPICS V4 runtime is composed of only 2 Jars, for the core, plus
2 if you want to access EPICS V3 IOCs, so you can
check the outcome of the builds with the find command below, to verify that from the 100s now
in your local Maven directory (probably <code>~/.m2/</code>), you have the few you really need. Again, <strong>actual
version tags, i.e. "2.1-SNAPSHOT" in the example below, will vary as EPICS V4 matures</strong>:</p>

<pre>
% find ~/.m2 -name "pv*SNAPSHOT.jar" -o -name "*caj*.jar" -o -name "*jca*.jar"
.m2/repository/epics/pvData/2.1-SNAPSHOT/pvData-2.1-SNAPSHOT.jar
.m2/repository/epics/jca/2.3.6/jca-2.3.6.jar
.m2/repository/epics/caj/1.1.10/caj-1.1.10.jar
.m2/repository/epics/pvAccess/2.1-SNAPSHOT/pvAccess-2.1-SNAPSHOT.jar
.m2/repository/epics/pvIOC/2.1-SNAPSHOT/pvIOC-2.1-SNAPSHOT.jar
</pre>

<p>Note that the results gave you not only jar files under <code>~/.m2/</code>, but the sources and
javadoc jars too (in the Maven standard naming).</p>

<p>The above completes the build of EPICS V4 locally. To use it, you would
write code that compiles and executes against the jar files above.</p>

<h4>Java Eclipse Development</h4>

<p>To use or develop these, the steps might be: </p>
<ul>
  <li>Install eclipse</li>
  <li>Either use a shell command, or EGit, to acquire the pv modules
  from a git repository. Using the shell mechanism you might:
  <ul>
    <li>Use a shell command to clone the Git repository as described
  above.</li>
  <li>If you cloned the Java projects into directory git/ change workspace to
  git/.</li>
  <li>In eclipse import from local Git repository.</li>
  </ul>
  </li>
  <li>Make pvAccessJava depend on pvDataJava, and adjust other dependencies for both of those.</li>
</ul>

<h4 id="javaexamples">Java Service Examples</h4>

<p>For Java client and server V4 service examples, at the time of writing, see the source code
in the examplesJava module. You can find this on the epics-pvdata web site
[<a href="#ev4examples-java">ev4examples-java</a>]. At the time of writing, examplesJava
contains 2 examples of RPC style servers (that is, pass arguments to an EPICS V4 pvAccess
server, get data back that is dependent on the arguments).</p>

<dl>
  <dt>helloWorld</dt>
  <dd>In particular, you may like to start with the,  <a
href="https://github.com/epics-base/exampleJava/tree/master/src/services/helloWorld">
helloWorld example service</a>. HelloWorld is composed of a server and a client. The
  server is built on top of the RPCSever framework in pvAccessJava.
  The service returns a string which greets
  that person and the client prints the received greeting. Start with its <a
  href="https://github.com/epics-base/exampleJava/tree/master/src/services/helloWorld/HELLOWORLD_README.txt"
  >HELLOWORLD_README.txt</a>. This demonstrates an EPICS V4 record whose value is subject to
  a user argument. The client and server interoperate with their C++ equivalents in exampleCPP.
</dd>
<dt>rdbService<dt>
  <dd>
  The <a href="https://github.com/epics-base/exampleJava/tree/master/src/services/rdbService"
>rdbService</a> example is a complete functional server for accessing SQL databases
such Oracle via an EPICS V4 server, and returning the resulting table ResultSet data
back to an EPICS V4 client. rdbService illustrates:
<ol>
  <li><code>channelRPC</code> functionality of EPICS V4</li>
  <li>use of JDBC for accessing Oracle to execute a SQL query within a pattern that
  retries the query and can rebuild the connection if any query fails - for high
  reliability and to make sure if the database backend ever cycles, the EPICS v4 server need
  not be restarted.</li>
  <li>Passing string messages back to the client in the event of the server
  detecting an error or other diagnostic</li> 
  <li>Putting complex data into an EPICS V4 pvStructure (the basic complex data
  object of pvData), ready for returning results back to the EPICS V4 client</li>
  <li>Client side calling the server, and getting the results</li>
  <li>Unpacking complex data out of a pvStructure</li>
  <li>Illustration of the idea of using the NTTable EPICS V4 "normative type" (though
  the definition of an NTTable is likely to change soon)</li>
  <li>Helpers for transformation of array pvData to Java Vectors</li>
  <li>Formatting pvStructure encoded data for printing.</li>
</ol>
</dd>
</dl>

  

<h2>C++ Development</h2>

<p>This section is on software development, with and of, the C++ implementation of
EPICS V4. It guides you through the process of acquiring the source, building the modules and running some simple examples.</p>

<h4 id="cppprerequisites">Prerequisites</h4>

<p>If you are already an EPICS V3 user, it's likely that, apart from the V4 source, you will already have everything you need to build the EPICS V4 C++ implementation from its source.</p>

<p>In addition to the EPICS V4 C++ source, you will need the following:

<ol>
<li>
<p>An installed version of EPICS (V3) Base. You should use 3.14.12 or later. You will also need the variable <code>EPICS_HOST_ARCH</code> appropriately set for your host architecture. See <a href="#appendix_a:_building_epics_v3_base">Appendix
A</a> for an an example of building a local EPICS Base, 3.14.12.3, and setting <code>EPICS_HOST_ARCH</code>.</p>
<p>For specific help for building on a Mac, see also <a
href="#appendix_b:_help_with_mac_os_x_build" >Appendix B: Help with Mac OS X build</a>.</p>
</li>

<li>
<p>You'll need gnu make and the C++ compiler used to build EPICS Base.</p>
</li>

<li>
<p>To build one example, the Channel Archiver Service, you will also need the EPICS Channel Archiver. See <a href=http://ics-web.sns.ornl.gov/kasemir/archiver/>http://ics-web.sns.ornl.gov/kasemir/archiver/</a>. Nothing else depends on this service and this can be omitted if desired.
</p>
</li>

<li>
<p>Some of the steps below will depend on you having specified the location of your EPICS Base installation through the shell variable <code>EPICS_BASE</code>. For example if your installation is in <code>/epics/R3.14.12.3/base</code>:
<pre>
% export EPICS_BASE=/epics/R3.14.12.3/base
</pre>
</p>
</li>

</ol>

<p>The <a
href="http://www.aps.anl.gov/epics/base/R3-14/12-docs/AppDevGuide/" >Application Developer's Guide</a> has more details on the set up required for building EPICS applications, including setting the host architecture and the versions of the various tools needed.

<h4 id="cppsource">Obtaining the source</h4>

<p>There are two ways to to get the EPICS V4 C++ source.</p>

<p>The simplest way is to download it as a tar from the Sourceforge website 
site <a href="http://sourceforge.net/projects/epics-pvdata/files/">
http://sourceforge.net/projects/epics-pvdata/files/</a>.
This is a good option if you wish to deploy EPICS V4 services and clients and want a stable release. The tar consists of a number of EPICS V4 modules and is designed to be relatively easy to build. This is recommended for those new to EPICS V4.</p>

<p>If you want the latest code or wish to contribute to development you will need to clone the Github repositories. In this case you can choose which modules you want.</p>

<p>The next two sections describe how to obtain the source and build it via these two methods.</p>

<h3 id="tarbuild">Building the EPICS V4.5.0 C++ Implementation Tar</h3>

<h4 id="quick_start">Quick start instructions</h4>

<p> For those familiar with EPICS V3 and with a V3 base installation and the appropriate toolchain already in place, doing the following should build the source (at least on Linux hosts).</p>

<p>You'll need <code>EPICS_BASE</code> set to point to your V3 base installation and <code>EPICS_HOST_ARCH</code> appropriately set. Download the V4.4.0 C++ tar from the SourceForge site
<a href="http://sourceforge.net/projects/epics-pvdata/files/4.5.0/">
http://sourceforge.net/projects/epics-pvdata/files/4.5.0/</a>, untar, configure and build:</p>
<pre>
% tar xzf EPICS-CPP-4.5.0.tar.gz
% cd EPICS-CPP-4.5.0
% chmod +x configure.sh
% make configure
% make
</pre>
<p>
[The command <code>make configure</code> sets your build dependencies. You can alternatively do this by creating and completing a top-level <code>RELEASE.local</code> based on <code>ExampleRelease.local</code>, which will work for other host architectures. ]<p>
<p>Then do the following to build pvaPy:
<pre>
% export EPICS4_DIR=`pwd`
% cd pvaPy
% make configure
% make
</pre>
</p>
<p>
For how to build the remaining target, the Channel Archiver Service, consult the sub-section of the step-by-step below.
</p>
<p><br></p>
<p>
For those less familiar with EPICS or requiring more information, the following sub-sections will take you through the requirements and build process step-by-step and in a little more detail:
</p>


<h4 id="step-by-step-cpp">Step by step</h4>
<ol>
<li>Download the V4.5.0 C++ tar.gz from the SourceForge site:

<a href="http://sourceforge.net/projects/epics-pvdata/files/4.5.0/">
http://sourceforge.net/projects/epics-pvdata/files/4.5.0/</a>.
</li>

<li>Untar it
<p>Move the tar to where you want your installation to be and untar it in the usual way:
<pre>
% tar xzf EPICS-CPP-4.5.0.tar.gz
</pre>
</p>
<p>If you <kbd>cd</kbd> into the resulting directory and examine the contents you should see something like
<pre>
% cd EPICS-CPP-4.5.0
% ls
CONFIG_SITE.local     Makefile           pvaPy          pvDataCPP
configure.sh          normativeTypesCPP  pvaSrv         README.md
exampleCPP            pvAccessCPP        pvCommonCPP    RELEASE_IDS
ExampleRelease.local  pvaClientCPP       pvDatabaseCPP  RELEASE_NOTES.md
</pre>
</p>
<li>Configure EPICS V4 for your site in CONFIG_SITE.local

<p>You can modify the default configuration for your site by setting this in CONFIG_SITE.local. This file is included by the CONFIG_SITE file in each module's configure directory.</p>

<p>The source tar should in general build out the box without modifying this CONFIG_SITE.local. This should be the case if your EPICS Base installation has no site-specific config. If this is not the case however you may have to modify CONFIG_SITE.local. If you have problems building the source tar you can try building against a clean EPICS Base without site-specific config.</p>

<p>Some site-specific configs may by default cause cross compilation for unsupported target architectures. To help ensure the tar builds out the box for as many new users as possible the supplied CONFIG_SITE.local sets
<code>CROSS_COMPILER_TARGET_ARCHS</code> to be an empty string:
  <pre>CROSS_COMPILER_TARGET_ARCHS=
</pre>
turning off any cross compilation. You can remove this line or set cross compilation targets here if you wish.
</p>
</li>
<li>Set your module locations in RELEASE.local,
<p>The EPICS build system needs you to specify the locations of the dependencies for each module. The easiest way to do this is to specify this in a single RELEASE.local in the top-level. This file will then be included by the RELEASE file in each module's configure directory.
</p>
<p>For Linux host development, a script is provided to make it easy to create your RELEASE.local, provided that you have specified the location of your EPICS Base installation through the shell variable <code>EPICS_BASE</code>. If your EPICS Base installation is in /epics/R3.14.12.3/base, from the top level of your EPICS V4 source do the following:
<pre>
% export EPICS_BASE=/epics/R3.14.12.3/base
% chmod +x configure.sh
% make configure
</pre>
</p>
<p>Alternatively create the RELEASE.local based on the supplied example. Save the file ExampleRelease.local as RELEASE.local and modify so that <code>EPICS_BASE</code> points to your EPICS Base installation and <code>EV4_BASE</code> points to the top-level EPICS V4 directory. So if you've untarred the source tar in /epicsv4 the file would look like.
<pre>
EV4_BASE=/epicsv4/EPICS-CPP-4.5.0
PVDATABASE=$(EV4_BASE)/pvDatabaseCPP
PVASRV=$(EV4_BASE)/pvaSrv
PVACCESS=$(EV4_BASE)/pvAccessCPP
NORMATIVETYPES=$(EV4_BASE)/normativeTypesCPP
PVDATA=$(EV4_BASE)/pvDataCPP
PVCOMMON=$(EV4_BASE)/pvCommonCPP
ARCHIVER=
EPICS_BASE=/epics/R3.14.12.3/base
</pre>
</p>
<p>[ Note: An alternative to a single top-level RELEASE.local is to specify the dependency locations on a per-module basis by creating a RELEASE.local in the configure directory. This allows you to specify only those modules you need and thus avoid recursive dependencies. You can do this through the configure script by typing
<pre>
% make config_multi
</pre>
instead of <code>make configure</code>. ]<p>

<li>Build the modules

<p>Simple type
<pre>
% make
</pre>
</p>
<p>This will build the default target which consist of the modules
pvCommonCPP, pvDataCPP,  normativeTypesCPP, pvAccessCPP, pvaSrv, pvDatabaseCPP and pvaClientCPP followed by exampleCPP/HelloWorld.
</p>
<li>Build pvaPy
<p>pvaPy is built separately as it has its own configuration script. From the top directory of the V4 source, do the following to build pvaPy:
<pre>
% export EPICS_BASE=/epics/R3.14.12.3/base
% export EPICS4_DIR=`pwd`
% cd pvaPy
% make configure
% make
</pre>
</p>

<li>Build the Channel Archiver Service (optional)

<p>This is an example EPICS V4 service. It is not part of the default target as it has an external dependency on the EPICS Channel Archiver. See <a href=http://ics-web.sns.ornl.gov/kasemir/archiver/>http://ics-web.sns.ornl.gov/kasemir/archiver/</a>.</p>

<p>The Channel Archiver can also be a little difficult to build. If it isn't part of your existing installation you may wish to leave this example out initially when getting started with EPICS V4.</p>

<p>To build the Channel Archiver Service example you will need to have built the EPICS Channel Archiver and to specify its location in the RELEASE.local. If your archiver is in the src/ChannelArchiver directory of /epics/R3.14.12.3/extensions then set in the <code>make configure</code>
<pre>
% ARCHIVER_DIR=/epics/R3.14.12.3/extensions make configure
</pre>
or set ARCHIVER in your RELEASE.local
<pre>
ARCHIVER=/epics/R3.14.12.3/extensions
</pre>
</p>

<p>Then to build the service, from the top directory, do
<pre>
% make archSrv
</pre>
or 
<pre>
% cd exampleCPP/ChannelArchiverService
% make
</pre>
</p>
</li>
</ol>


<h3>Building the EPICS V4.5.0 C++ Implementation from the Repositories</h3>

<p>For the latest code or to contribute to development you will need to clone the Github repositories.
This will of course give you the full revision history of the modules including previous releases and all branches.
</p>

<p>Note there is no single, top-level repository, so you will need to obtain the modules you want and build them individually.

<h4>Getting the EPICS V4 C++ Implementation source</h4>

<p>The modules can be obtained using the Git clone command.</p>

<p>
For this you will <a href="#prerequisites">need the Git client tools, as described above</a>.
Choose the location for your EPICS V4 modules and obtain the required modules with a Git clone using either the SSH or HTTP URI.
You're not required to put all the modules in the same directory, but it makes sense and can simplify the build process.
The minimum you'll need is the modules pvCommonCPP, pvDataCPP and pvAccessCPP. So if you're using the SSH URI, clone as follows:

<pre>[commands issued from the desired location for each repo]
% git clone https://github.com/epics-base/pvCommonCPP.git
% git clone https://github.com/epics-base/pvDataCPP.git
% git clone https://github.com/epics-base/pvAccessCPP.git
</pre>
</p>

<p>Other modules can be obtained similarly:

<pre>% git clone https://github.com/epics-base/exampleCPP.git
% git clone https://github.com/epics-base/normativeTypesCPP.git
% git clone https://github.com/epics-base/pvaSrv.git
% git clone https://github.com/epics-base/pvDatabaseCPP.git
% git clone https://github.com/epics-base/pvaClientCPP.git
% git clone https://github.com/epics-base/pvaPy.git

</pre>
</p>

<h4>Building the EPICS V4 C++ implementation source with make</h4>

The C++ implementations of the EPICS V4 modules use the EPICS V3 build system, based on unix <code>make</code>
(in contrast to the Java implementation, which uses Maven).
A basic understanding of the EPICS V3 make system is helpful, although the following instructions do not assume this knowledge.
The build command itself is simple - it's just <kbd>make</kbd>.
However you will have to do some configuration - in particular specifying where the modules' dependencies are and possibly also which targets are built.
</p>

<p>EPICS V4 uses the EPICS build facility. In particular each module has a directory called <code>configure</code> containing a file, <code>CONFIG_SITE</code>, which is used to specify build choices and target architectures and another, <code>RELEASE</code>, which is used to specify directory structures containing files needed by the module (i.e. the locations of dependencies).</p>

<p>For EPICS V4 modules <code>CONFIG_SITE</code> includes files <code>CONFIG_SITE.local</code> in the <code>configure</code> directory or in the module's parent directory (providing these exist).</p>

<p>Similarly  <code>RELEASE</code> includes files <code>RELEASE.local</code> in the <code>configure</code> directory or in the module's parent directory (again, providing these exist).</p>


<p>So you can create a <code>configure/RELEASE.local</code> for each module specifying the module's dependencies or you can create a single <code>RELEASE.local</code> in the parent directory of a group of modules containing all the dependencies for those modules. The former has the advantage that you can specify only those dependencies you need (which prevents issues with recursive dependencies). The latter has the advantage that you only need specify the dependency locations once.
</p>

<p>Similarly if you need to, you can create <code>configure/CONFIG_SITE.local</code> for each module specifying build choices and targets or you can create a single <code>CONFIG_SITE.local</code> in the parent directory of the group of modules. For example the line
  <pre>CROSS_COMPILER_TARGET_ARCHS=
</pre>
specifies that there are no cross compilation targets, i.e. the only target is the host architecture.
</p>

<p>You may which to create a top-level makefile to simplify your build process. You can get an example makefile and configuration script, as well as an example <code>RELEASE.local</code> and <code>CONFIG_SITE.local</code> from the source tar (see <a href="#tarbuild">Building the EPICS V4.5.0 C++ Implementation Tar</a>)
 or from the EPICS V4 website. For example on Linux or Mac you might wget (<i>if you get Unsupported Scheme error, try curl -O &lt;url&gt; instead</i>):
<pre>
% wget https://raw.githubusercontent.com/epics-base/pvDataWWW/master/scripts/Makefile
% wget https://raw.githubusercontent.com/epics-base/pvDataWWW/master/scripts/configure.sh
% wget https://raw.githubusercontent.com/epics-base/pvDataWWW/master/scripts/CONFIG_SITE.local
% wget https://raw.githubusercontent.com/epics-base/pvDataWWW/master/scripts/RELEASE.local
</pre>
</p>

<p>The instructions below do not assume a top-level Makefile.</p>

<h4 id="cppbuild">EPICS V4 Core C++ Implementation Build</h4>

<p>As a minimum you'll need to build the two core modules pvData and pvAccess as well as the module pvCommon on which these depend.
The build dependencies of the EPICS v4 core modules are:</p>

<ul>
<li>pvCommonCPP depends on EPICS Base</li>
<li>pvDataCPP depends on pvCommonCPP and EPICS Base</li>
<li>pvAccessCPP depends on pvCommonCPP, pvDataCPP and EPICS Base</li>
</ul>

The module interdependencies require that they are <b>built in the
following order: first pvCommonCPP, then pvDataCPP, and finally pvAccessCPP</b>, as detailed below.
</p>
<p>
It is assumed that your EPICS V4 modules are all in a single parent directory.
</p>
<p>To build the core modules
<ol>
  <li><p>Specify the dependencies for all the modules: In the parent directory (i.e. the directory containing pvCommonCPP, pvDataCPP and pvAccessCPP) create a
  <code>RELEASE.local file</code> which sets <code>EPICS_BASE</code> to point to your EPICS release and PVCOMMON and PVDATA to point to the locations of pvCommon and pvData respectively. So if your EPICS V4 source is in <code>/epics/v4/latest</code> and your EPICS Base in <code>/epics/R3.14.12.3/base</code> your <code>RELEASE.local</code> will be
<pre>
PVDATA=/epics/v4/latest/pvDataCPP
PVCOMMON=/epics/v4/latest/pvCommonCPP
EPICS_BASE=/epics/R3.14.12.3/base
</pre>

<p> In addition set any targets or build choices. For example, if you need to prevent cross-compiling set <code>CROSS_COMPILER_TARGET_ARCHS</code> to be the empty string by creating a <code>CONFIG_SITE.local</code> in the parent directory which contains the line<p>
  <pre>CROSS_COMPILER_TARGET_ARCHS=
</pre>
</p>
  </li>

  <li><p>Build pvCommon: <kb>cd</kb> into <code>pvCommonCPP</code> and build the module:
<pre>[from the top level directory of pvCommonCPP, issue make]
% make </pre>
</p>
<p>pvCommon should then build without errors.</p>
  </li>

  <li><p>Build pvData: <kb>cd</kb> into <code>pvDataCPP</code> and build the module:
<pre>[from the top level directory of pvDataCPP, issue make]
% make </pre>
</p>
<p>pvData should then build without errors.</p>
  </li>
 
  <li><p>Build pvAccess: Again, <kb>cd</kb> into <code>pvAccessCPP</code> and build the module:
<pre>[from the top level directory of pvAccessCPP, issue make]
% make </pre>
</p>
<p>pvAccess should build without errors.</p>
 </li>
</ol>
</p>

<h4 id="exampleCPP">Building exampleCPP</h4>

<p>The module exampleCPP currently contains two C++ examples of RPC-style clients and servers.

These services require that you have built the core modules as described above.
In addition the Channel Archiver Service has a dependency on the EPICS V3 Channel Archiver. See <a href=http://ics-web.sns.ornl.gov/kasemir/archiver/>http://ics-web.sns.ornl.gov/kasemir/archiver/</a>.</p>

<p>To build the HelloWorld, you need to specify the dependency locations in a <code>RELEASE.local</code>, e.g. this should include the lines like:
<pre>
EV4_BASE=/epicsv4/latest
PVACCESS=$(EV4_BASE)/pvAccessCPP
PVDATA=$(EV4_BASE)/pvDataCPP
PVCOMMON=$(EV4_BASE)/pvCommonCPP
EPICS_BASE=/epics/R3.14.12.3/base
</pre>
depending on your EPICS Base and V4 module locations. This file can be located in the parent directory of exampleCPP, in the parent of HelloWorld (i.e. in exampleCPP) or in <code>HelloWorld/configure</code>.
</p>
<p>Then <kbd>cd</kbd> into the HelloWorld directory and type <kbd>make<kbd>.

<p>
The instructions are similar for ChannelArchiverService, except that you will need to specify the location of the Archiver, e.g.
<pre>
EV4_BASE=/epicsv4/latest
PVACCESS=$(EV4_BASE)/pvAccessCPP
PVDATA=$(EV4_BASE)/pvDataCPP
PVCOMMON=$(EV4_BASE)/pvCommonCPP
ARCHIVER=/epics/R3.14.12.3/extensions
EPICS_BASE=/epics/R3.14.12.3/base
</pre>
before you <kbd>cd</kbd> into the ChannelArchiverService directory and type <kbd>make</kbd>.
</p>

<p>
More detailed instructions for building and running the services are in their respective READMEs <a
  href="https://github.com/epics-base/exampleCPP/tree/master/HelloWorld/HELLOWORLD_README.txt"
  >HELLOWORLD_README.txt</a> and <a
  href="https://github.com/epics-base/exampleCPP/tree/master/ChannelArchiverService/CHANNEL_ARCHIVER_SERVICE__README.txt"
  >CHANNEL_ARCHIVER_SERVICE__README.txt</a> (and also available in the source).
</p>


<h4 id="exampleCPP">Building the other EPICS V4 C++ modules</h4>

<p>The other modules are built in a similar fashion, typing <kbd>make</kbd> in each module, after first specifying dependencies in a <code>RELEASE.local</code> and build choices and targets in a <code>CONFIG_SITE.local</code> in either each module's <code>configure</code> directory or in the parent directory.<p>

<p>The remaining EPICS V4 modules have the following dependencies:
<ul>
<li>pvaSrv depends on pvDataCPP and pvAccessCPP</li>
<li>pvaClientCPP and pvaPy depend on pvDataCPP, pvAccessCPP and normativeTypesCPP</li>
<li>pvDatabaseCPP depends on pvDataCPP, pvAccessCPP and (for example code) pvaSrv</li>
</ul>
<ul>

<h3>Running the C++ Examples</h3>

<p>A number of examples of C++ EPICS V4 clients and servers are available, either included in the source tar or in EPICS V4 modules cloned from GitHub.
</p>

<p>This section describes running a few of these. It assumes you have built the EPICS V4 core modules either from the tar or from clones of the repositories and have put <code>pvAccess/bin/$EPICS_HOST_ARCH</code> in your path, e.g.
<pre>
PATH=$PATH:/epicsv4/EPICS-CPP-4.5.0
</pre>
</p>

<h4 id="cppexamples">C++ Example RPC services</h4>

<p>
The module exampleCPP contains examples of C++ clients and servers.
You can find this on the epics-pvdata web site
[<a href="#ev4examples-cpp">ev4examples-cpp</a>].
As of release 4.3 it is also included in the downloaded sourcefile tar.
</p>

<p>
Currently examplesCPP contains 2 examples of RPC-style servers.</p>

<dl>
  <dt>HelloWorld</dt>
  <dd>As with the Java examples, a good place to start is with the
<a href="https://github.com/epics-base/exampleCPP/tree/master/HelloWorld">
HelloWorld example service</a>. The HelloWorld in exampleCPP is the C++ equivalent of the one in exampleJava,
i.e. is composed of a server and a client. The client sends the server a name and prints the response from
the server which is a greeting addressed to the supplied name. See <a
  href="https://github.com/epics-base/exampleCPP/tree/master/HelloWorld/HELLOWORLD_README.txt"
  >HELLOWORLD_README.txt</a>. The client and server interoperate with their Java equivalents in exampleJava.
</dd>

<dt>ChannelArchiverService<dt>
  <dd>
  The <a href="https://github.com/epics-base/exampleCPP/tree/master/ChannelArchiverService"
>ChannelArchiverService</a> example is a complete functional EPICS V4 server for accessing an EPICS Channel Archiver index file
and returning the archive data back to an EPICS V4 client.
It can be queried using the eget utility but also includes
a client which provides additional processing and formatting of the results.
ChannelArchiverService illustrates:</P>
<ol>
  <li><code>channelRPC</code> functionality of EPICS V4 </li>
  <li>EPICS V4 service API using the NTURI EPICS V4 "normative type"</li>
  <li>Passing string messages back to the client in the event of the server
  detecting an error or other diagnostic</li> 
  <li>Putting complex data into an EPICS V4 pvStructure (the basic complex data
  object of pvData), ready for returning results back to the EPICS V4 client</li>
  <li>Client side calling the server and getting the results</li>
  <li>Unpacking complex data out of a pvStructure</li>
  <li>Illustration of the idea of using the NTTable EPICS V4 "normative type"</li>
  <li>Formatting pvStructure encoded data for printing.</li>
</ol>
See <a
  href="https://github.com/epics-base/exampleCPP/tree/master/ChannelArchiverService/CHANNEL_ARCHIVER_SERVICE__README.txt"
  >CHANNEL_ARCHIVER_SERVICE__README.txt</a>.
</dd>
</dl>

<p><strong>Running the HelloWorld example</strong>.</p>

<p>Having built the HelloWorld example you can the server and client. The service is very simple. The client supplies a string and the server responds with a greeting based on the string.</p>

<p>To run the HelloWorld example, start the HelloWorld server: <kbd>cd</kbd> to the directory containing HelloWorld and start the server in one terminal 
<pre>
% cd /epicsV4/EPICS-CPP-4.4.0/exampleCPP/HelloWorld
% ./helloServerRunner
</pre>
</p>
<p>
You should something like:
<pre>
pvAccess Server v4.0.3
VERSION : pvAccess Server v4.0.3
PROVIDER_NAMES : rpcService
BEACON_ADDR_LIST : 
AUTO_BEACON_ADDR_LIST : 1
BEACON_PERIOD : 15
BROADCAST_PORT : 5076
SERVER_PORT : 5075
RCV_BUFFER_SIZE : 16384
IGNORE_ADDR_LIST: 
STATE : INITIALIZED
</pre>
</p>

<p>Then on the  client, run the HelloWorld Client in a terminal
<pre>
% cd /epicsV4/EPICS-CPP-4.5.0/exampleCPP/HelloWorld
% ./helloClientRunner Dave
</pre>
and you should see
<pre>
Hello Dave
</pre>
</p>
<p>
You can also use the eget utility in pvAccess:
<pre>
% eget -z -N -s helloService -a "personsname=Dave"
</pre>
which produces
<pre>
structure 
    string greeting Hello Dave
</pre>
</p>
<p>After you've finished testing the server you can terminate it with a SIGTERM like CTRL-C in the server process window.
</p>


<p>
More detailed instructions for building and running the services are in their respective READMEs.
These services can be used a model for starting to write your own services.
</p>

<h4>Adding pvAccess support to an IOC</h4>

<p>This section describes an example of the use of pvaSrv, the C++ implementation of EPICS
 V4 to access EPICS V3 PVs. That is, a version 3 IOC makes the values of its V3 channels
available through pvAccess to EPICS V4 pvAccess clients.</p> 
<p>You should already have built pvaSrv, either from the SourceForge tar or as a module cloned from the Git repository. The pvaSrv build (assuming it was successful) has created a ready-to-run example.
  The source code for it is in the directory <code>pvaSrv/testApp/dbPv</code>. To run it do the following:

<p>
From <code>pvaSrv</code> <kbd>cd</kbd> to <code>testTop/iocBoot/testDbPv</code>.
From here you can start the test IOC (on the host, as a "soft" IOC):
<pre>
% ../../bin/$EPICS_HOST_ARCH/testDbPv st.cmd
</pre>
</p>
<p>
The EPICS databases are in <code>pvaSrv/testApp/db</code>. You can add db files, templates etc. there.
Edit the st.cmd to make it load your EPICS databases.
</p>


<p><strong>sample output from running the IOC</strong>.</p>

<pre>
% ../../bin/$EPICS_HOST_ARCH/testDbPv st.cmd
< envPaths
epicsEnvSet("ARCH","linux-x86_64")
epicsEnvSet("IOC","testDbPv")
epicsEnvSet("TOP","/epicsv4/EPICS-CPP-4.5.0/latest/pvaSrv/testTop")
epicsEnvSet("PVASRV","/epicsv4/EPICS-CPP-4.5.0/latest/pvaSrv/testTop/..")
epicsEnvSet("EV4_BASE","/epicsv4/EPICS-CPP-4.5.0")
epicsEnvSet("PVACCESS","/epicsv4/EPICS-CPP-4.5.0/pvAccessCPP")
epicsEnvSet("PVDATA","/epicsv4/EPICS-CPP-4.5.0/pvDataCPP")
epicsEnvSet("PVCOMMON","/epicsv4/EPICS-CPP-4.5.0/pvCommonCPP")
epicsEnvSet("EPICS_BASE","/epics/R3.14.12.3/base")
cd /epicsv4/EPICS-CPP-4.5.0/pvaSrv/testTop
## Register all support components
dbLoadDatabase("dbd/testDbPv.dbd")
testDbPv_registerRecordDeviceDriver(pdbbase)
## Load record instances
dbLoadRecords("db/dbInteger.db","name=byte01,type=byter")
dbLoadRecords("db/dbInteger.db","name=short01,type=shortr")
dbLoadRecords("db/dbInteger.db","name=ubyte01,type=ubyte")
dbLoadRecords("db/dbInteger.db","name=ushort01,type=ushort")
dbLoadRecords("db/dbInteger.db","name=uint01,type=ulong")
dbLoadRecords("db/dbInteger.db","name=int01,type=longout")
dbLoadRecords("db/dbInteger.db","name=wait01,type=wait")
dbLoadRecords("db/dbScalar.db","name=float01,type=floatr")
dbLoadRecords("db/dbScalar.db","name=double01,type=ai")
dbLoadRecords("db/dbArray.db","name=byteArray01,type=CHAR")
dbLoadRecords("db/dbArray.db","name=shortArray01,type=SHORT")
dbLoadRecords("db/dbArray.db","name=intArray01,type=LONG")
dbLoadRecords("db/dbArray.db","name=ubyteArray01,type=UCHAR")
dbLoadRecords("db/dbArray.db","name=ushortArray01,type=USHORT")
dbLoadRecords("db/dbArray.db","name=uintArray01,type=ULONG")
dbLoadRecords("db/dbArray.db","name=floatArray01,type=FLOAT")
dbLoadRecords("db/dbArray.db","name=doubleArray01,type=DOUBLE")
dbLoadRecords("db/dbString.db","name=string01")
dbLoadRecords("db/dbBigstringin.db","name=bigstring01")
dbLoadRecords("db/dbStringArray.db","name=stringArray01")
dbLoadRecords("db/dbEnum.db","name=enum01")
dbLoadRecords("db/dbCounter.db","name=counter01");
dbLoadRecords("db/dbInteger.db","name=byte02,type=byter")
dbLoadRecords("db/dbInteger.db","name=short02,type=shortr")
dbLoadRecords("db/dbInteger.db","name=ubyte02,type=ubyte")
dbLoadRecords("db/dbInteger.db","name=ushort02,type=ushort")
dbLoadRecords("db/dbInteger.db","name=uint02,type=ulong")
dbLoadRecords("db/dbInteger.db","name=int02,type=longout")
dbLoadRecords("db/dbInteger.db","name=wait02,type=wait")
dbLoadRecords("db/dbScalar.db","name=float02,type=floatr")
dbLoadRecords("db/dbScalar.db","name=double02,type=ai")
dbLoadRecords("db/dbArray.db","name=byteArray02,type=CHAR")
dbLoadRecords("db/dbArray.db","name=shortArray02,type=SHORT")
dbLoadRecords("db/dbArray.db","name=intArray02,type=LONG")
dbLoadRecords("db/dbArray.db","name=floatArray02,type=FLOAT")
dbLoadRecords("db/dbArray.db","name=doubleArray02,type=DOUBLE")
dbLoadRecords("db/dbString.db","name=string02")
dbLoadRecords("db/dbStringArray.db","name=stringArray02")
dbLoadRecords("db/dbEnum.db","name=enum02")
dbLoadRecords("db/dbCounter.db","name=counter02");
dbLoadRecords("db/dbInteger.db","name=byte03,type=byter")
dbLoadRecords("db/dbInteger.db","name=short03,type=shortr")
dbLoadRecords("db/dbInteger.db","name=ubyte03,type=ubyte")
dbLoadRecords("db/dbInteger.db","name=ushort03,type=ushort")
dbLoadRecords("db/dbInteger.db","name=uint03,type=ulong")
dbLoadRecords("db/dbInteger.db","name=int03,type=longout")
dbLoadRecords("db/dbInteger.db","name=wait03,type=wait")
dbLoadRecords("db/dbScalar.db","name=float03,type=floatr")
dbLoadRecords("db/dbScalar.db","name=double03,type=ai")
dbLoadRecords("db/dbArray.db","name=byteArray03,type=CHAR")
dbLoadRecords("db/dbArray.db","name=shortArray03,type=SHORT")
dbLoadRecords("db/dbArray.db","name=intArray03,type=LONG")
dbLoadRecords("db/dbArray.db","name=floatArray03,type=FLOAT")
dbLoadRecords("db/dbArray.db","name=doubleArray03,type=DOUBLE")
dbLoadRecords("db/dbString.db","name=string03")
dbLoadRecords("db/dbStringArray.db","name=stringArray03")
dbLoadRecords("db/dbEnum.db","name=enum03")
dbLoadRecords("db/dbCounter.db","name=counter03");
cd /epicsv4/EPICS-CPP-4.5.0/latest/pvaSrv/pvaSrv/testTop/iocBoot/testDbPv
iocInit()
Starting iocInit
############################################################################
## EPICS R3.14.12.3 $Date: Mon 2012-12-17 14:11:47 -0600$
## EPICS Base built Mar 18 2015
############################################################################
iocRun: All initialization complete
epicsThreadSleep(2.0)
casr
Channel Access Server V4.13
No clients connected.
startPVAServer
VERSION : pvAccess Server v4.1.2
PROVIDER_NAMES : dbPv
BEACON_ADDR_LIST : 
AUTO_BEACON_ADDR_LIST : 1
BEACON_PERIOD : 15
BROADCAST_PORT : 5076
SERVER_PORT : 5075
RCV_BUFFER_SIZE : 16384
IGNORE_ADDR_LIST: 
STATE : INITIALIZED
dbpf string01 10.1
DBR_STRING:          "10.1"   
dbpf wait01 1
DBR_SHORT:          1         0x1                 
dbpf wait02 2
DBR_SHORT:          2         0x2                 
dbpf wait03 3
DBR_SHORT:          3         0x3                 
epics> 
</pre>



<h2 class="nocount" id="appendix:a">Appendix A: Building EPICS Base</h3>
<p>An example of downloading and building EPICS V3 version 3.14.12, on Mac OS X, is
given below. An EPICS Base install is a prerequisite for compilation of
the C++ implementations of the EPICS V4 core modules.</p>
<p>Begin by downloading the tar file of the EPICS Base from the EPICS main
web site at Argonne: <a href="http://www.aps.anl.gov/epics/base/R3-14/12.php"
>http://www.aps.anl.gov/epics/base/R3-14/12.php</a>. In this example, having
downloaded
the tar,  it is moved into the directory where EPICS Base is to be built.</p>
<pre>
% mkdir epicsV3
% cd epicsV3
% mv ~/Downloads/baseR3.14.12.3.tar .
% tar xvf baseR3.14.12.3.tar
% cd base-3.14.12.3/
</pre>
<p>
You will also need gnu make, perl and, of course, a C++ compiler e.g. g++.
</p>
<p>
To build you will need to specify your host architecture by setting your host architecture. A script is provided to help you select this. For example for Linux:
<pre>
% ./startup/EpicsHostArch
linux-x86_64
% export EPICS_HOST_ARCH=linux-x86_64
</pre>
</p>
<p>
Then build:
<pre>
% make
</pre>
</p>
<p>
See the  <a
href="http://www.aps.anl.gov/epics/base/R3-14/12-docs/AppDevGuide/" >Application Developer's Guide</a>, especially the Build Facility" section for more details on the setting the host architecture and the required tools. 
</p>
<p>See below for help with Mac build in Mac OS 10.8 (Mountain Lion) is you have
  issues with make, compiling or linking.</p>


<h2 class="nocount" id="appendix:b">Appendix B: Help with Mac OS X build</h2>

<p id="lionhelp">The EPICS Base build ran perfectly on the author's Mac running Mac
  OS X 10.7.3. However, for Mac OS 10.8 (Mountain Lion), there were 2
  issues. Firstly, it seems make is no longer distributed and installed by default in
  10.8. One can however choose to install the Mac OS command line tools,
  see <a href="http://stackoverflow.com/questions/11494522/installing-make-on-mac/11494872#11494872"
  >this comment on Stackoverflow.com</a> for help.</p>

<p>Additionally, there seem to be a change in the compiler support of Mac OS 10.8,
  causing an error such as the following at link time: </p>

<pre>
ld: library not found for -lgcc
</pre>

<p>Try adding the line following line to your
  configure/os/CONFIG_SITE.Common.darwin-x86 file [Thanks to Andrew Johnson for this
  help]:</p>

<pre>
GNU = NO
</pre>
or this line if that 
doesn't work:
<pre>
GNU_LDLIBS_YES = 
</pre>

<p>V4.4 requires Java 1.7. Java on a Mac can be a bit confused since Java from Oracle now installs Java differently to the way Apple did it. The Java Control Panel may not know all the versions known by java_home. You may need to set JAVA_HOME explicitly. For example: </p>
<pre>
$ export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
</pre>

<! --
<p>Following the builds of pvCommonCPP, pvDataCPP, pvAccessCPP, pvIOCCPP and pvaSrv detailed above,
the envPaths file used to run the V3 Channel test example,
pvIOCCPP/iocBoot/testV3Channel, was as follows:</p>

<pre>
% cat envPaths 
epicsEnvSet("ARCH","darwin-x86")
epicsEnvSet("IOC","testV3Channel")
epicsEnvSet("TOP","/Users/greg/Development/epicsV4/ev4hg/pvIOCCPP")
epicsEnvSet("EPICS_BASE","/Users/greg/Development/epicsV3/base-<br/>")
epicsEnvSet("PVCOMMON","$(TOP)/../pvCommonCPP")
epicsEnvSet("PVDATA","$(TOP)/../pvDataCPP")
epicsEnvSet("PVACCESS","$(TOP)/../pvAccessCPP")
epicsEnvSet("PVIOC","$(TOP)/../pvIOCCPP")
</pre>
-- >
-->

<h2 class="nocount">References</h2>

<dt id="downloadsite">[EPICS V4 download site]</dt>
  <dd>EPICS V4 download site, <a
    href="http://sourceforge.net/projects/epics-pvdata/files/">http://sourceforge.net/projects/epics-pvdata/files/</a>
  </dd>

<dt id="ev4examples-java">[ev4examples-java]</dt>
  <dd>EPICS V4 Java Examples repository, <a
  href="https://github.com/epics-base/exampleJava">https://github.com/epics-base/exampleJava</a>
  </dd>

<dt id="ev4examples-cpp">[ev4examples-cpp]</dt>
  <dd>EPICS V4 C++ Examples repository, <a
  href="https://github.com/epics-base/exampleCPP">https://github.com/epics-base/exampleCPP</a>
  </dd>

<dt id="EPICSV4repos">[EPICSV4repos]</dt>
  <dd>EPICS V4 Git Repositories, <a
    href="https://github.com/epics-base/" >
    https://github.com/epics-base/</a>
  </dd>

<dt id="bib:jca">[jcaandcaj]</dt>
  <dd>JCA and CAJ, Sourceforge, Matej Sekoranja,  
    <a href="http://epics-jca.sourceforge.net">http://epics-jca.sourceforge.net</a>
    </dd>

<dt id="bib:relver">[relver]</dt>
  <dd>RELEASE_VERSIONS, the files which defines which modules are in each release of EPICS V4 (apart from EPICS Base),  
    <a href="https://github.com/epics-base/pvDataWWW/blob/master/scripts/RELEASE_VERSIONS">RELEASE_VERSIONS</a>
    </dd>
  <dt id="bib:epicsappdev">[epicsappdev]</dt>
      <dd>EPICS
Input / Output Controller (IOC) Application Developer's Guide, Marty Kraimer, <a href="http://www.aps.anl.gov/epics/base/R3-14/12-docs/AppDevGuide/">http://www.aps.anl.gov/epics/base/R3-14/12-docs/AppDevGuide/</a></dd>
</div>

<hr />
<address>Greg White, SLAC, PSI. Dave Hickin, Diamond. Timo Korhonen, ESS. Ralph Lange, ITER</address>
<!-- hhmts start -->Last modified: Wed Oct  19 05:40:58 PDT 2015 <!-- hhmts end -->

</body>
</html><pre>
